#!/usr/local/bin/php
<?php
require('db_settings.inc');

/**
 * If this script is being run after a conflict, the temp files would still exist.
 * Deleting all temp files if this script is run after a conflict.
 */
if(file_exists("$file_path/tmp/data_merged.sql")){ 
  exec("rm $file_path/tmp/*"); 
}


/**
 * To store production sequences, the full original production version of the 
 * database will be loaded into MySQL.
 */
exec("$script_path/restore_database --prod --min");


/**
 * Set up ability to strip data from tables
 */
foreach($tables_content as $content_table){ 
  $strip_content .= "|grep -v 'INSERT INTO .".$content_table.". VALUES' "; 
}
foreach($tables_users as $users_table){ 
  $strip_users .= "|grep -v 'INSERT INTO .".$users_table.". VALUES' "; 
}


/**
 * Set up ability to strip primary keys from incremental tables
 */
foreach($tables_increment as $increment_table){ 
  $strip_increment .= "| sed 's/INSERT INTO .".$increment_table.". VALUES ([0-9][0-9]*,/INSERT INTO `".$increment_table."` VALUES (NULL,/g' "; 
}


/**
 * Set up ability to strip SQL comments
 */
foreach($sql_comment_unset as $comment){ 
  $strip_comment .= "|grep -v '".$comment."' "; 
}


/**
 * To ensure that the newly merged databases get imported into the database correctly,
 * tables that were modified to not be dropped in development, need to be reversed
 */

foreach($tables_preserved_full as $table) {
  $reverse_filter .= "|sed 's/CREATE TABLE IF NOT EXISTS .".$table.". (/DROP TABLE IF EXISTS `".$table."`; CREATE TABLE `".$table."` (/g' ";
}


/**
 * Take development database and strip it of content and user data to 
 *   create a skeleton to work from (skeleton.sql)
 */
exec("cat $file_path/development.sql $strip_content $strip_users $strip_terms $strip_comment $reverse_filter > $file_path/tmp/skeleton.sql");

// copy skeleton to where we'll be building the newly merged database
exec("cp $file_path/tmp/skeleton.sql $file_path/tmp/merged_database.sql");


/**
 * Add production user data to start building the newly merged database
 */
foreach($tables_users as $user_table){
  exec("grep 'INSERT INTO .".$user_table.". VALUES' $file_path/production.sql >> $file_path/tmp/data_user.sql");
}
exec("cat $file_path/tmp/data_user.sql >> $file_path/tmp/merged_database.sql");


/**
 * Grab data from production, development and merged databases
 * Strip auto increment table sequences to avoid conflicts
 */
if(file_exists("$file_path/tmp/data_dev.sql")){ exec("rm $file_path/tmp/data_dev.sql"); }
if(file_exists("$file_path/tmp/data_prod.sql")){ exec("rm $file_path/tmp/data_prod.sql"); }
if(file_exists("$file_path/tmp/data_lastmerge.sql")){ exec("rm $file_path/tmp/data_lastmerge.sql"); }

foreach($tables_content as $content_table){
  exec("grep 'INSERT INTO .".$content_table.". VALUES' $file_path/development.sql $strip_increment >> $file_path/tmp/data_dev.sql");
  exec("grep 'INSERT INTO .".$content_table.". VALUES' $file_path/production.sql $strip_increment >> $file_path/tmp/data_prod.sql");
  exec("grep 'INSERT INTO .".$content_table.". VALUES' $file_path/last-merge.sql $strip_increment >> $file_path/tmp/data_lastmerge.sql");
}


/**
 * Create a new merged version of data (this step takes awhile)
 *   NOTE: requires GNU diff3
 */
exec("diff3 -E --merge $file_path/tmp/data_dev.sql $file_path/tmp/data_lastmerge.sql $file_path/tmp/data_prod.sql > $file_path/tmp/data_merged.sql");


/*
 * Check to see if the patch had conflicts.  Otherwise, continue.
 */
$conflicts = exec("grep '^<<<<<<<' $file_path/tmp/data_merged.sql");
if($conflicts){

  print("\nWARNING: The database has conflicts!\n\n");

  print("Please check $file_path/tmp/data_merged.sql for what conflicted\n");
  print("(hint: search for <<<<<<<), then:\n");
  print("  * Resolve the conflicts manually\n");
  print("  * Save $file_path/tmp/data_merged.sql\n\n");

  print("NOTE: If you want to default all conflicts to production values, run this command instead of resolving manually:\n\n");

  print("diff3 -e --merge $file_path/tmp/data_dev.sql $file_path/tmp/data_orig.sql $file_path/tmp/data_prod.sql > $file_path/tmp/data_merged.sql\n\n");

  print("After resolving conflicts, run the following commands (just copy and paste):\n\n"); 

  print("cat $file_path/tmp/data_merged.sql >> $file_path/tmp/merged_database.sql\n");
  print("cp $file_path/tmp/merged_database.sql $file_path/development.sql\n");
  print("cp $file_path/tmp/merged_database.sql $file_path/production.sql\n");
  print("$script_path/restore_database --prod --min --sequences\n");
  print("$script_path/dump_database --prod --min\n");
  print("$script_path/restore_database\n");
  print("$script_path/dump_database\n");
  print("cp $file_path/development.sql $file_path/last-merge.sql\n");
  print("$script_path/restore_database --prod --min\n\n");



} else {

  /*
   * Append the merged data to the merged version we're building
   */
  exec("cat $file_path/tmp/data_merged.sql >> $file_path/tmp/merged_database.sql");


  /*
   * Apply the merged data to the databases
   */
  exec("cp $file_path/tmp/merged_database.sql $file_path/development.sql");
  exec("cp $file_path/tmp/merged_database.sql $file_path/production.sql");


  /*
   * Restore and dump databases so they are formated correctly with correct  
   * sequences for their version and prepared to be committed into svn.
   *
   * Production is restored first to align the database with the sequences currently 
   * in MySQL (which is the production version), then restored again after 
   * development to leave the MySQL status ready to be testing for the live version
   */
  exec("$script_path/restore_database --prod --min --sequences");
  exec("$script_path/dump_database --prod --min");
  exec("$script_path/restore_database");
  exec("$script_path/dump_database");
  exec("cp $file_path/development.sql $file_path/last-merge.sql"); // Merged database is a copy of development
  exec("$script_path/restore_database --prod --min");


  /*
   * Delete temp files
   */
  exec("rm $file_path/tmp/*");

  print("Merge completed successfully.  Congrats! Pat yourself on the back.\n");

}

