#!/usr/local/bin/php
<?php
require('db_settings.inc');

/**
 * If this script is being run after a conflict, the temp files would still exist.
 * Deleting all temp files if this script is run after a conflict.
 */
if(file_exists($path."dbscripts/databases/tmp/data_merged.sql")){ 
  exec("rm ".$path."dbscripts/databases/tmp/*"); 
}


/**
 * To store production sequences, the full original production version of the 
 * database will be loaded into MySQL.
 */
exec($path."dbscripts/restore_prod_database");


/**
 * Set up ability to strip data from tables
 */
foreach($tables_content as $content_table){ 
  $strip_content .= "|grep -v 'INSERT INTO .".$content_table.". VALUES' "; 
}
foreach($tables_users as $users_table){ 
  $strip_users .= "|grep -v 'INSERT INTO .".$users_table.". VALUES' "; 
}


/**
 * Set up ability to strip primary keys from incremental tables
 */
foreach($tables_increment as $increment_table){ 
  $strip_increment .= "| sed 's/INSERT INTO .".$increment_table.". VALUES ([0-9][0-9]*,/INSERT INTO `".$increment_table."` VALUES (NULL,/g' "; 
}


/**
 * Set up ability to strip SQL comments
 */
foreach($sql_comment_unset as $comment){ 
  $strip_comment .= "|grep -v '".$comment."' "; 
}


/**
 * To ensure that the newly merged databases get imported into the database correctly,
 * tables that were modified to not be dropped in development, need to be reversed
 */

foreach($tables_preserved_dev as $table) {
  $reverse_filter .= "|sed 's/CREATE TABLE IF NOT EXISTS .".$table.". (/DROP TABLE IF EXISTS `".$table."`; CREATE TABLE `".$table."` (/g' ";
}


/**
 * Take development database and strip it of content and user data to 
 *   create a skeleton to work from (skeleton.sql)
 */
exec("cat ".$path."dbscripts/databases/development.sql $strip_content $strip_users $strip_terms $strip_comment $reverse_filter > ".$path."dbscripts/databases/tmp/skeleton.sql");

// copy skeleton to where we'll be building the newly merged database
exec("cp ".$path."dbscripts/databases/tmp/skeleton.sql ".$path."dbscripts/databases/tmp/merged_database.sql");


/**
 * Add production user data to start building the newly merged database
 */
foreach($tables_users as $user_table){
  exec("grep 'INSERT INTO .".$user_table.". VALUES' ".$path."dbscripts/databases/production.sql >> ".$path."dbscripts/databases/tmp/data_user.sql");
}
exec("cat ".$path."dbscripts/databases/tmp/data_user.sql >> ".$path."dbscripts/databases/tmp/merged_database.sql");


/**
 * Grab data from production, development and merged databases
 * Strip auto increment table sequences to avoid conflicts
 */
if(file_exists($path.'dbscripts/databases/tmp/data_dev.sql')){ exec('rm '.$path.'dbscripts/databases/tmp/data_dev.sql'); }
if(file_exists($path.'dbscripts/databases/tmp/data_prod.sql')){ exec('rm '.$path.'dbscripts/databases/tmp/data_prod.sql'); }
if(file_exists($path.'dbscripts/databases/tmp/data_lastmerge.sql')){ exec('rm '.$path.'dbscripts/databases/tmp/data_lastmerge.sql'); }

foreach($tables_content as $content_table){
  exec("grep 'INSERT INTO .".$content_table.". VALUES' ".$path."dbscripts/databases/development.sql $strip_increment >> ".$path."dbscripts/databases/tmp/data_dev.sql");
  exec("grep 'INSERT INTO .".$content_table.". VALUES' ".$path."dbscripts/databases/production.sql $strip_increment >> ".$path."dbscripts/databases/tmp/data_prod.sql");
  exec("grep 'INSERT INTO .".$content_table.". VALUES' ".$path."dbscripts/databases/last-merge.sql $strip_increment >> ".$path."dbscripts/databases/tmp/data_lastmerge.sql");
}


/**
 * Create a new merged version of data (this step takes awhile)
 *   NOTE: requires GNU diff3
 */
exec("diff3 -E --merge ".$path."dbscripts/databases/tmp/data_dev.sql ".$path."dbscripts/databases/tmp/data_lastmerge.sql ".$path."dbscripts/databases/tmp/data_prod.sql > ".$path."dbscripts/databases/tmp/data_merged.sql");


/*
 * Check to see if the patch had conflicts.  Otherwise, continue.
 */
$conflicts = exec("grep '^<<<<<<<' ".$path."dbscripts/databases/tmp/data_merged.sql");
if($conflicts){

  print("\nWARNING: The database has conflicts!\n\n");

  print("Please check ".$path."dbscripts/databases/tmp/data_merged.sql for what conflicted\n");
  print("(hint: search for <<<<<<<), then:\n");
  print("  * Resolve the conflicts manually\n");
  print("  * Save ".$path."dbscripts/databases/tmp/data_merged.sql\n\n");

  print("NOTE: If you want to default all conflicts to production values, run this command instead of resolving manually:\n\n");

  print("diff3 -e --merge ".$path."dbscripts/databases/tmp/data_dev.sql ".$path."dbscripts/databases/tmp/data_orig.sql ".$path."dbscripts/databases/tmp/data_prod.sql > ".$path."dbscripts/databases/tmp/data_merged.sql\n\n");

  print("After resolving conflicts, run the following commands (just copy and paste):\n\n"); 

  print("cat ".$path."dbscripts/databases/tmp/data_merged.sql >> ".$path."dbscripts/databases/tmp/merged_database.sql\n");
  print("cp ".$path."dbscripts/databases/tmp/merged_database.sql ".$path."dbscripts/databases/development.sql\n");
  print("cp ".$path."dbscripts/databases/tmp/merged_database.sql ".$path."dbscripts/databases/production.sql\n");
  print($path."dbscripts/restore_prod_database_sans_sequences\n");
  print($path."dbscripts/dump_prod_database\n");
  print($path."dbscripts/restore_dev_database\n");
  print($path."dbscripts/dump_dev_database\n");
  print("cp ".$path."dbscripts/databases/development.sql ".$path."dbscripts/databases/last-merge.sql\n");
  print($path."dbscripts/restore_prod_database\n\n");



} else {

  /*
   * Append the merged data to the merged version we're building
   */
  exec("cat ".$path."dbscripts/databases/tmp/data_merged.sql >> ".$path."dbscripts/databases/tmp/merged_database.sql");


  /*
   * Apply the merged data to the databases
   */
  exec("cp ".$path."dbscripts/databases/tmp/merged_database.sql ".$path."dbscripts/databases/development.sql");
  exec("cp ".$path."dbscripts/databases/tmp/merged_database.sql ".$path."dbscripts/databases/production.sql");


  /*
   * Restore and dump databases so they are formated correctly with correct  
   * sequences for their version and prepared to be committed into svn.
   *
   * Production is restored first to align the database with the sequences currently 
   * in MySQL (which is the production version), then restored again after 
   * development to leave the MySQL status ready to be testing for the live version
   */
  exec($path."dbscripts/restore_prod_database_sans_sequences");
  exec($path."dbscripts/dump_prod_database");
  exec($path."dbscripts/restore_dev_database");
  exec($path."dbscripts/dump_dev_database");
  exec("cp ".$path."dbscripts/databases/development.sql ".$path."dbscripts/databases/last-merge.sql"); // Merged database is a copy of development
  exec($path."dbscripts/restore_prod_database");


  /*
   * Delete temp files
   */
  exec("rm ".$path."dbscripts/databases/tmp/*");

  print("Merge completed successfully.  Congrats! Pat yourself on the back.\n");

}

