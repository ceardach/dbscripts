<?php

/**
 * Get the database connection settings from settings.php file
 */
function dbscripts_db_connect() {
  require('config.inc');
  require("$settings_path/settings.php");

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";
  if (!isset($db_url)) return "The file 'settings.php' file does not exist.";

  preg_match('/'.$dbtype.':\/\/([^:]+):([^@]+)@([^\/]+)\/(.+)/', $db_url, $db_settings);

  if (empty($db_settings)) {
    return FALSE;
  } else {

    $dbuser = $db_settings[1];
    $dbpassword = $db_settings[2];
    $dbhost = $db_settings[3];
    $dbname = $db_settings[4];

    return "-u $dbuser -p$dbpassword -h $dbhost $dbname";
  }
}


/**
 * Get options for dump file and filtering
 *
 * @param $argv
 *   Pass in the $_SERVER['argv'] variable to return options set when running
 *   the script.
 */
function dbscripts_get_options($argv) {
  $use_default = FALSE;
  if(isset($argv[1])) {
    if(in_array($argv[1],array('min','none','full'))) {
      $use_default = TRUE;
    }
  } else {
    $use_default = TRUE;
  }

  if ($use_default) {
    $options['file'] = 'development';
    $filter_options = isset($argv[1]) ? $argv[1] : '';
  } else {
    $options['file'] = $argv[1];
    $filter_options = isset($argv[2]) ? $argv[2] : '';
  }

  switch ($filter_options) {
    case 'min':
    $options['filter'] = 'min';
      break;

    case 'none':
      $options['filter'] = 'none';
      break;

    default:
      $options['filter'] = 'full';
      break;
  }

  return $options;
}


/**
 * Dump the database
 *
 * @param $branch
 *   Branch that the database should be dumped to.  Defaults to 'development'.
 *   Alternative options that are supported by default are 'production' and
 *   'last-merge'.  Other string patterns may be used if you wish to dump the
 *   the database to an alternate location.
 * @param $filter_option
 *   Choose what level of filtering should be performed during the dump.  Filter
 *   levels are configured in config.inc
 *   'full' - Default option.  Removes the full option of data from the dump.
 *       Most useful for removing user, sessions and cache data.  Use this when
 *       dumping a development database.
 *   'min' - Removes only a select minimum of data from the dump.  Most useful
 *       for removing sessions and cache data.  Use this when dumping a
 *       production database.
 *   'none' - NO filtering is performed whatsoever.  The entire database is
 *       dumped.
 */
function dbscripts_dump($branch = 'development', $filter_option = 'full', $lastmerge_branch = 'last-merge') {
  require('config.inc');
  require('config.references.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";
  if (!isset($tables_referenced)) return "The file 'config.references.inc' does not exist.  Copy from the example version?";

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
  }

  $dump_location = "$dump_path/$branch";
  $lastmerge_location = "$dump_path/$lastmerge_branch";
  $temp_location = "$dump_path/tmp";
  $workspace_branch = "workspace/last-dump";
  $workspace_location = "$dump_path/$workspace_branch";

  // Creating required folders
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");
  if (!file_exists("$dump_location/data")) exec("mkdir -p $dump_location/data");
  if (!file_exists("$dump_location/tables")) exec("mkdir -p $dump_location/tables");
  if (!file_exists("$workspace_location/tables")) exec("mkdir -p $workspace_location/tables");
  if (!file_exists("$workspace_location/data")) exec("mkdir -p $workspace_location/data");

  $lastmerge_exists = FALSE;
  if (file_exists("$lastmerge_location") && file_exists("$dump_location/table_list.txt")) {
    $lastmerge_exists = TRUE;
  }

  // Set the filtering options and message to be presented to the user
  $tables_cleared = array();
  $fix_user_table = FALSE;
  switch($filter_option){
    case 'none':
      $message = "Performed a full database dump to $branch.";
      break;

    case 'min':
      $tables_cleared = array_merge($tables_filtered, $tables_filtered_l1);
      $message = "Dumped the database to $branch with minimal filtering.";
      break;

    default:
      $tables_cleared = array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2);
      $fix_user_table = TRUE;
      $message = "Dumped the database to $branch with full filtering options.";
      break;
  }

  // Create an array of all tables in the database and store it
  exec("$mysqldump --add-drop-table --no-data $db_connection_settings | grep 'DROP TABLE' | sed -e \"s/DROP TABLE IF EXISTS .//g\" -e \"s/.;//g\" > $workspace_location/table_list.txt");
  $table_list = file("$workspace_location/table_list.txt", FILE_IGNORE_NEW_LINES);

  // These are all the special dump options that make the database diffable
  // and preserve character set
  $dump_options = "--skip-opt --add-drop-table --add-locks --create-options --quick --lock-tables --set-charset --disable-keys --order-by-primary --skip-comments --comments=FALSE --default-character-set=utf8 --character-sets-dir=$charsets --hex-blob";

  // Dump the structure of all tables
  if (exec("ls $temp_location")) exec("rm -r $temp_location/*");
  foreach ($table_list as $table) {
  	exec("$mysqldump $dump_options --no-data $db_connection_settings --tables $table > $temp_location/$table.sql");
  }

  // Check that a file actually has data, and stop if it doesn't
  if (file_get_contents("$temp_location/$table_list[0].sql") == '') {
    exec("rm $temp_location/*");
    return "\nEmpty data returned.  There may be a problem connecting to the database.\n\n";
  }

  // Move the table files to the working space's last dump
  if (exec("ls $workspace_location/tables")) exec("rm $workspace_location/tables/*");
  exec("mv $temp_location/* $workspace_location/tables");

  // Remove all AUTO_INCREMENT values of the filtered tables
  $tables_to_filter = dbscripts_process_tables($workspace_branch, $tables_cleared, FALSE);
  foreach ($tables_to_filter as $table) {
    $filtered_increment = dbscripts_get_table_increment($table, $workspace_branch);
    exec("sed 's/ AUTO_INCREMENT={$filtered_increment['num']}//g' $workspace_location/tables/$table.sql > $temp_location/$table.sql");
    exec("mv $temp_location/$table.sql $workspace_location/tables/$table.sql");
  }

  // Find out which tables contain new data, and potentially new data
  if ($branch != $lastmerge_branch && $lastmerge_exists) {

    // Get all tables that have content that would need to be merged
    $tables_to_merge = dbscripts_process_tables($workspace_branch, $tables_merge, FALSE);

    // Find references for each table
    foreach ($tables_to_merge as $table) {

      // Get the current and lastmerge increments of the table
      $increment = dbscripts_get_table_increment($table, $workspace_branch);
      $increment_lastmerge = dbscripts_get_table_increment($table, $lastmerge_branch);

      // Continue only if there is a possibility of new data or a reference
      if (isset($increment['num']) && isset ($increment_lastmerge['num']) && $increment['num'] > $increment_lastmerge['num']) {

        // Not error checking when finding references because it takes too long
        $references = dbscripts_get_table_references($table, $workspace_branch, $filter_option, FALSE);

        // Compare the primary keys of the referencing table with
        // the foreign keys of the referenced table
        foreach ($references['references'] as $referenced_table => $columns) {
          $primary_keys = dbscripts_get_table_primary_keys($referenced_table, $branch);
          if (is_array($primary_keys)) {
            foreach ($columns as $column) {
              if (in_array($column, $primary_keys)) {
                // Record the table/column pair along with the lastmerge increment value
                $tables_with_new_data[$referenced_table][$column] = $increment_lastmerge['num'];
              }
            }
          }
        }

      }

    }

  }

  // Get tables to be dumped by removing $tables_cleared from the list of all tables
  $tables_dumped = dbscripts_process_tables($workspace_branch, $tables_cleared);
  if (!is_array($tables_dumped)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
    return "\n$tables_dumped\n\n";
  }

  // Dump the data of all tables we're tracking
  foreach ($tables_dumped as $table) {
    if (isset($tables_with_new_data[$table])) {
      // Create the where statements
      $where_clause_new = '';
      $where_clause_old = '';
      $where_clause_new_data = array();
      $where_clause_old_data = array();
      foreach ($tables_with_new_data[$table] as $column => $increment) {
        $where_clause_new_data[] = "$column>=$increment";
        $where_clause_old_data[] = "$column<$increment";
      }

      // Where statement for new data
      $where_clause_new = "--where='";
      foreach ($where_clause_new_data as $key => $query) {
        if ($key != 0) {
          $where_clause_new .= " OR ";
        }
        $where_clause_new .= $query;
      }
      $where_clause_new .= "'";

      // Where statement for old data
      $where_clause_old .= "--where='";
      foreach ($where_clause_old_data as $key => $query) {
        if ($key != 0) {
          $where_clause_old .= " AND ";
        }
        $where_clause_old .= $query;
      }
      $where_clause_old .= "'";

      exec("$mysqldump $dump_options --no-create-info $db_connection_settings $where_clause_old --tables $table > $temp_location/$table.sql");
      exec("$mysqldump $dump_options --no-create-info $db_connection_settings $where_clause_new --tables $table > $temp_location/$table-new.sql");
    } else {
      exec("$mysqldump $dump_options --no-create-info $db_connection_settings --tables $table > $temp_location/$table.sql");
    }

    // If there's no data, then delete the file
    if (!exec("grep 'INSERT INTO' $temp_location/$table.sql")) {exec("rm $temp_location/$table.sql");}
    if (file_exists("$temp_location/$table-new.sql")) {
      if (!exec("grep 'INSERT INTO' $temp_location/$table-new.sql")) exec("rm $temp_location/$table-new.sql");
    }
  }

  // Move the data files to the working space's last dump
  if (exec("ls $workspace_location/data")) exec("rm $workspace_location/data/*");
  exec("mv $temp_location/* $workspace_location/data");

  // Fix the users table issue with conflicting timestamps
  // Just use the last-merge timestamp
  if ($fix_user_table) {
    // Define paths
    $dumped_version = "$workspace_location/data/users.sql";
    $lastmerge_version = "$lastmerge_location/data/users.sql";
    $dumped_converted_version = "$temp_location/users.txt";
    $lastmerge_converted_version = "$temp_location/users.txt";
    $rewritten_version = "$temp_location/users.csv";
    $new_version = "$temp_location/users.sql";

    // Columns to work with (minus 1 for arrays)
    $uid_column = 1;
    $access_column = 10;
    $login_column = 11;

    // Create a converted version of the user table
    exec("
        grep 'INSERT INTO' $dumped_version \\
        |sed -e 's/^INSERT INTO `users` VALUES (//g' -e 's/);$//g' \\
        |sed -e 's/#/#PND#/g' -e \"s/\\\\\'/#SQ#/g\" -e \"s/\\\\\\\"/#DQ#/g\" \\
        | awk -f $script_path/csv.awk -f $script_path/convert.awk \\
        |sed -e 's/#CM#$//g' \\
        > $dumped_converted_version
    ");
    exec("
        grep 'INSERT INTO' $lastmerge_version \\
        |sed -e 's/^INSERT INTO `users` VALUES (//g' -e 's/);$//g' \\
        |sed -e 's/#/#PND#/g' -e \"s/\\\\\'/#SQ#/g\" -e \"s/\\\\\\\"/#DQ#/g\" \\
        | awk -f $script_path/csv.awk -f $script_path/convert.awk \\
        |sed -e 's/#CM#$//g' \\
        > $lastmerge_converted_version
    ");

    // Convert to arrays
    $dumped_converted_file = file("$dumped_converted_version", FILE_IGNORE_NEW_LINES);
    $lastmerge_converted_file = file("$lastmerge_converted_version", FILE_IGNORE_NEW_LINES);

    // Put the UID as the array key, with an array of columns
    foreach ($dumped_converted_file as $line) {
      $line_parts = explode('#CM#', $line);
      $dumped_converted[$line_parts[0]] = $line_parts;
    }
    foreach ($lastmerge_converted_file as $line) {
      $line_parts = explode('#CM#', $line);
      $lastmerge_converted[$line_parts[0]] = $line_parts;
    }

    // Rewrite the timestamps
    foreach ($dumped_converted as $uid => $columns) {
      $rewritten_timestamps[$uid] = $columns;
      if (isset($lastmerge_converted[$uid])) {
        $rewritten_timestamps[$uid][$access_column] = $lastmerge_converted[$uid][$access_column];
        $rewritten_timestamps[$uid][$login_column] = $lastmerge_converted[$uid][$login_column];
      }
    }

    // Write the rewritten version to file
    foreach ($rewritten_timestamps as $columns) {
      $line = '';
      foreach ($columns as $key => $column) {
        if ($key == 0) {
          $line = $column;
        } else {
          $line .= ",$column";
        }
      }
      exec("echo \"$line\" >> $rewritten_version");
    }

    // Convert the file to SQL
    $sql = file("$lastmerge_version", FILE_IGNORE_NEW_LINES);

    // Get the top sql comments
    $data_start = '';
    foreach ($sql as $key => $line) {
      if (!$data_start) {
        if (preg_match("/^INSERT INTO/", $line)) {
          $data_start = $key;
        } else {
          $line = str_replace("'", "#SQ#", $line); // issues with quotes
          if ($key == 0) {
            exec("echo '$line' > $temp_location/top.sql");
          } else {
            exec("echo '$line' >> $temp_location/top.sql");
          }
        }
      }
    }
    exec("sed \"s/#SQ#/\\'/g\" $temp_location/top.sql > $new_version"); // reverting quotes

    // Insert the data
    exec("
        cat $rewritten_version \\
        |sed -e \"s/#DQ#/\\\\\\\"/g\" -e \"s/#SQ#/\\\\\'/g\" -e 's/#PND#/#/g' \\
        |sed -e 's/^/INSERT INTO `users` VALUES (/g' -e 's/$/);/g' \\
        >> $new_version
    ");

    // Insert the bottom sql comments
    foreach ($sql as $key => $line) {
      if ($key > $data_start && !preg_match("/^INSERT INTO/", $line)) {
        $line = str_replace("'", "#SQ#", $line); // issues with quotes
        exec("echo '$line' >> $temp_location/bottom.sql");
      }
    }
    exec("sed \"s/#SQ#/\\'/g\" $temp_location/bottom.sql >> $new_version"); // reverting quotes

    // Copy the results over to the new dump
    exec("mv $new_version $dumped_version");

    // Delete files that are no longer required
    exec("rm $temp_location/top.sql $temp_location/bottom.sql $lastmerge_converted_version $rewritten_version");
  }

  // For now we're just going to directly copy everything to $dump_location
  // Eventually we'll actually perform a merge
  exec("rm -r $dump_location/*");
  exec("cp -R $workspace_location/* $dump_location");


  // Let the user know what happened
  return "\n$message\n\n";
}


/**
 * Erase the database
 *
 * @param $filter_option
 *   Choose what level of filtering should be performed while erasing the
 *   database.  Filter levels are configured in config.inc.  Any options set to
 *   be filtered will be subsequently PRESERVED in the database, and not erased.
 *   'full' - Default option.  Preserves the full option of data from the dump.
 *       Most useful for keeping user, sessions and cache data.  Use this when
 *       erasing a development database.
 *   'min' - Preserves only a select minimum of data from the dump.  Most useful
 *       for keeping sessions data so you don't get logged out.  Use this when
 *       erasing a production database.
 *   'none' - NO filtering is performed whatsoever.  The entire database will be
 *       erased.
 */
function dbscripts_erase($filter_option = 'full') {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
  }

  // Set the filtering options and message to be presented to the user
  $tables_preserved = array();
  switch ($filter_option) {
    case 'none';
      $message = "Erased the entire database.";
      break;

    case 'min':
      $tables_preserved = $tables_filtered_l1;
      $message = "Erased the database, except for minimal preserved tables.";
      break;

    default:
      $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
      $message = "Erased the database, except for preserved tables.";
      break;
  }

  $filter = '';
  foreach($tables_preserved as $preserved_data) {
    $filter .= "|grep -v 'DROP TABLE IF EXISTS .$preserved_data.;'";
  }

  // Dump options to make it easy to erase the database
  $dump_options = "--add-drop-table --no-data";

  // We'll dump the database, perform some changes to it, then pipe it back into
  // MySQL so it will drop the given tables
  exec("$mysqldump $dump_options $db_connection_settings | grep 'DROP TABLE' $filter | $mysql $db_connection_settings");

  return "\n$message\n\n";
}


/**
 * Restore the database
 *
 * @param $branch
 *   File the database should be restored from.  Defaults to 'development'.
 *   Alternative options that are supported by default are 'production' and
 *   'last-merge'.  Other filename patterns may be used if you wish to restore
 *   the database from an alternate location.
 * @param $filter_option
 *   Choose what level of filtering should be performed during the restoration.
 *   Filter levels are configured in config.inc
 *   'full' - Default option.  Preserves the full option of data currently
 *       residing within MySQL. Most useful for preserving user, sessions and
 *       cache data.  Use this when restoring within a development environment.
 *   'min' - Preserves only a select minimum of data currently residing within
 *       MySQL.  Most useful for preserving sessions and cache data.  Use this
 *       when restoring within a production environment.
 *   'none' - NO filtering is performed whatsoever.  The entire database is
 *       erased from MySQL and restored with the data from the given file.
 */
function dbscripts_restore($branch = 'development', $filter_option = 'full') {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
  }

  // Set locations
  $dump_location = "$dump_path/$branch";
  $workspace_location = "$dump_path/workspace/last-restore";

  // Check that the requested location exists
  if (!file_exists($dump_location)) {return "\nThe path does not exist: $dump_location\n\n";}
  if (!file_exists($workspace_location)) {exec("mkdir -p $workspace_location");}

  // Set behavior depending on filter
  $tables_preserved = array();
  switch($filter_option){
    case 'none':
      $message = "Restored the full database";
      break;

    case 'min':
      $tables_preserved = $tables_filtered_l1;
      $message = "Restored the database perserving minimal tables";
      break;

    default:
      $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
      $message = "Restored the database preserving the full option of tables";
      break;
  }

  // Erase the database so any tables that were removed stay removed
  dbscripts_erase($filter_option);

  // Get a list of tables to restore by removing $tables_preserved from the list of all tables
  $tables_restored = dbscripts_process_tables($branch, $tables_preserved);
  if (!is_array($tables_restored)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
  	return "\n$tables_restored\n\n";
  }

  // Restore each database file
  foreach ($tables_restored as $table) {
    if (file_exists("$dump_location/tables/$table.sql")) exec("$mysql $db_connection_settings < $dump_location/tables/$table.sql");
    if (file_exists("$dump_location/data/$table.sql")) exec("$mysql $db_connection_settings < $dump_location/data/$table.sql");
    if (file_exists("$dump_location/data/$table-new.sql")) exec("$mysql $db_connection_settings < $dump_location/data/$table-new.sql");
  }

  // Move what was restored to the working space
  if (exec("ls $workspace_location")) {exec("rm -r $workspace_location/*");}
  exec("cp -R $dump_location/* $workspace_location");

  return "\n$message\n\n";
}


/**
 * Merge databases
 *
 * You really only need to set the following parameters for expert use.
 * Otherwise this function can be run with no options.
 *
 * @param $dev_branch
 *   Location of the database file that was used for 'development'.  Only
 *   configuration and content changes will be preserved.  All user data will
 *   be lost.
 * @param $lastmerge_branch
 *   Location of the database file that was used to represent the state the
 *   last time both production and development were merged.  This is important
 *   to be able to track the difference between an addition and a subtraction.
 * @param $prod_branch
 *   Location of the database file that is used as 'production'.  Only content
 *   and user data will be perserved.  All other data will be lost.
 */
function dbscripts_merge($dev_branch = 'development', $lastmerge_branch = 'last-merge', $prod_branch = 'production', $continue = FALSE) {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // If empty data gets sent through, reset it to defaults
  if (!$dev_branch) $dev_branch = 'development';
  if (!$lastmerge_branch) $lastmerge_branch = 'last-merge';
  if (!$prod_branch) $prod_branch = 'production';

  // Set all locations
  $temp_location = "$dump_path/tmp";
  $dev_location = "$dump_path/$dev_branch";
  $lastmerge_location = "$dump_path/$lastmerge_branch";
  $prod_location = "$dump_path/$prod_branch";
  $merge_location = "$temp_location/merge";
  $tmpdev_branch = "tmp/dev";
  $tmpdev_location = "$dump_path/$tmpdev_branch";
  $conflict_file = "$temp_location/conflict.txt";

  // Ensure all the branches exist
  $missing_branch = '';
  if (!file_exists($dev_location)) $missing_branch .= $dev_branch.' ';
  if (!file_exists($lastmerge_location)) $missing_branch .= $lastmerge_branch.' ';
  if (!file_exists($prod_location)) $missing_branch .= $prod_branch.' ';

  // Cancel merge if all branches do not exist
  if ($missing_branch) {
    return "\nFAILED: Missing database files for merge: $missing_branch\n\n";
  }

  // Ensure tmp folder exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  // CONTINUE MERGE
  // If a previous merge had a conflict, it'll be picked up and continued here
  if ($continue) {

    if (file_exists($conflict_file)) {
      $conflicted_tables = file($conflict_file, FILE_IGNORE_NEW_LINES);

      foreach ($conflicted_tables as $table) {
        // Set the location of the merge files for existing and new data
        $existing_version = "$merge_location/data/$table.sql";
        $new_version = "$temp_location/$table.sql";
        $temp_version = "$temp_location/$table-tmp.sql";

        // Ensure the file exists
        if (!file_exists($existing_version)) {
          return "\nI thought you resolved conflicts in '$table', but the file is missing.\nAre you trying to confuse me??\n\n";
        }

        // Ensure that the merge was actually resolved
        $check_conflict = exec("grep '^<<<<<<<' $existing_version");
        if ($check_conflict) {
           return "\n'$table' still has conflicts, please resolve them first.\n\n";
        }

        // If there was any new data to this table, we'll have to merge the two
        if (file_exists($new_version)) {
          $sql = file("$existing_version", FILE_IGNORE_NEW_LINES);

          // Get the top sql comments
          $data_start = '';
          foreach ($sql as $key => $line) {
            if (!$data_start) {
              if (preg_match("/^INSERT INTO/", $line)) {
                $data_start = $key;
              } else {
                $line = str_replace("'", "#SQ#", $line); // issues with quotes
                if ($key == 0) {
                  exec("echo '$line' > $temp_location/top.sql");
                } else {
                  exec("echo '$line' >> $temp_location/top.sql");
                }
              }
            }
          }
          exec("sed \"s/#SQ#/\\'/g\" $temp_location/top.sql > $temp_version"); // reverting quotes

          // Insert the data
          exec("grep '^INSERT INTO' $existing_version >> $temp_version");
          exec("grep '^INSERT INTO' $new_version >> $temp_version");

          // Insert the bottom sql comments
          foreach ($sql as $key => $line) {
            if ($key > $data_start && !preg_match("/^INSERT INTO/", $line)) {
              $line = str_replace("'", "#SQ#", $line); // issues with quotes
              exec("echo '$line' >> $temp_location/bottom.sql");
            }
          }
          exec("sed \"s/#SQ#/\\'/g\" $temp_location/bottom.sql >> $temp_version"); // reverting quotes

          // Copy the results over to where we're storing data
          exec("mv $temp_version $existing_version");

          // Delete files that are no longer required
          exec("rm $temp_location/top.sql $temp_location/bottom.sql $new_version");
        }

      }

      // Delete the conflict file
      exec("rm $conflict_file");

    } else {
      return "\nI cannot find '$conflict_file', so I cannot continue :(\n\n";
    }

  } else {

  // After a conflict, the temp files would still exist, so delete everything and start over
  if (exec("ls $temp_location")) exec("rm -r $temp_location/*");

  // Creating merge folders
  if (!file_exists($merge_location)) exec("mkdir -p $merge_location/tables $merge_location/data");
  exec("cp -R $dev_location $tmpdev_location");

  // Define the tables, fail if they don't return arrays
  $tables_content = dbscripts_process_tables($dev_branch, $tables_merge, FALSE);
  if (!is_array($tables_content)) {
  	return "\n$tables_content\n\n";
  }
  $tables_prod = dbscripts_process_tables($prod_branch, $tables_override, FALSE);
  if (!is_array($tables_prod)) {
    return "\n$tables_prod\n\n";
  }
  $tables_dev = dbscripts_process_tables($dev_branch, array_merge($tables_merge, $tables_override));
  if (!is_array($tables_dev)) {
    return "\n$tables_dev\n\n";
  }

  // Raise all the increments of the content tables of development to above production values
  print "\nRaising increments of the '$dev_branch' branch ";
  foreach ($tables_content as $table) {
    print "."; // gheto status messages
    // Find the last-merge value
    $lastmerge_increment = dbscripts_get_table_increment($table, $lastmerge_branch);
    $start_at = $lastmerge_increment['num'];

    // Find the production value
    $production_increment = dbscripts_get_table_increment($table, $prod_branch);
    $change_to = $production_increment['num'];

    if ($start_at < $change_to) {
      // Raise the increments
      dbscripts_raise_table_increments($table, $start_at, $change_to, $tmpdev_branch);
    }
  }
  print "\n"; // gheto status messages

  // Move all development tables and data to the temp merge location
  foreach (array_merge($tables_dev, $tables_content) as $table) {
  	if (file_exists("$tmpdev_location/tables/$table.sql")) exec("cp $tmpdev_location/tables/$table.sql $merge_location/tables");
    if (file_exists("$tmpdev_location/data/$table.sql")) exec("cp $tmpdev_location/data/$table.sql $merge_location/data");
  }

  // Move all the production tables and data to the temp merge location
  foreach ($tables_prod as $table) {
    if (file_exists("$prod_location/tables/$table.sql")) exec("cp $prod_location/tables/$table.sql $merge_location/tables");
    if (file_exists("$prod_location/data/$table.sql")) exec("cp $prod_location/data/$table.sql $merge_location/data");
  }

  // DATA MERGING
  // Merge the data from development into the production values
  print "\nMerging content ";
  $conflict = array();
  exec("echo '' > $conflict_file");
  foreach ($tables_content as $table) {
    print "."; // gheto status messages
    // Ensure there is actually some data to work with
    $known_data_file = file_exists("$tmpdev_location/data/$table.sql") ? "$tmpdev_location/data/$table.sql" : (file_exists("$lastmerge_location/data/$table.sql") ? "$lastmerge_location/data/$table.sql" : (file_exists("$prod_location/data/$table.sql") ? "$prod_location/data/$table.sql" : FALSE));
    $known_data_file = $known_data_file ? $known_data_file : (file_exists("$tmpdev_location/data/$table-new.sql") ? "$tmpdev_location/data/$table-new.sql" : (file_exists("$prod_location/data/$table-new.sql") ? "$prod_location/data/$table-new.sql" : FALSE));

    // Set data paths
    $blank_version = "$temp_location/blank.sql";
    $dev_version = file_exists("$tmpdev_location/data/$table.sql") ? "$tmpdev_location/data/$table.sql" : $blank_version;
    $lastmerge_version = file_exists("$lastmerge_location/data/$table.sql") ? "$lastmerge_location/data/$table.sql" : $blank_version;
    $prod_version = file_exists("$prod_location/data/$table.sql") ? "$prod_location/data/$table.sql" : $blank_version;
    $dev_version_new = file_exists("$tmpdev_location/data/$table-new.sql") ? "$tmpdev_location/data/$table-new.sql" : '';
    $prod_version_new = file_exists("$prod_location/data/$table-new.sql") ? "$prod_location/data/$table-new.sql" : '';
    $merge_version = "$merge_location/data/$table.sql";
    $temp_version = "$temp_location/$table.sql";

    // Only go through with the merge if there is any data to work with
    if ($known_data_file || $dev_version_new || $prod_version_new) {
      // Create a blank version for merge with diff3 purposes
      exec("grep -v '^INSERT INTO' $known_data_file > $blank_version");

      // Merge the existing data
      exec("diff3 -E --merge $dev_version $lastmerge_version $prod_version > $merge_version");
      $check_conflict = exec("grep '^<<<<<<<' $merge_version");
      if ($check_conflict) {
         $conflict[] = $table;
         exec("echo '$table' > $conflict_file");
      }

      // Merge the new data
      if (($dev_version_new || $prod_version_new)) {
        $sql = file("$known_data_file", FILE_IGNORE_NEW_LINES);

        // Get the top sql comments
        $data_start = '';
        foreach ($sql as $key => $line) {
          if (!$data_start) {
            if (preg_match("/^INSERT INTO/", $line)) {
              $data_start = $key;
            } else {
              $line = str_replace("'", "#SQ#", $line); // issues with quotes
              if ($key == 0) {
                exec("echo '$line' > $temp_location/top.sql");
              } else {
                exec("echo '$line' >> $temp_location/top.sql");
              }
            }
          }
        }
        exec("sed \"s/#SQ#/\\'/g\" $temp_location/top.sql > $temp_version"); // reverting quotes

        // Insert the data
        if (!in_array($table, $conflict) && file_exists($merge_version)) exec("grep '^INSERT INTO' $merge_version >> $temp_version");
        if ($prod_version_new) exec("grep '^INSERT INTO' $prod_version_new >> $temp_version");
        if ($dev_version_new) exec("grep '^INSERT INTO' $dev_version_new >> $temp_version");

        // Insert the bottom sql comments
        foreach ($sql as $key => $line) {
          if ($key > $data_start && !preg_match("/^INSERT INTO/", $line)) {
            $line = str_replace("'", "#SQ#", $line); // issues with quotes
            exec("echo '$line' >> $temp_location/bottom.sql");
          }
        }
        exec("sed \"s/#SQ#/\\'/g\" $temp_location/bottom.sql >> $temp_version"); // reverting quotes

        // Delete temp files
        exec("rm $temp_location/top.sql $temp_location/bottom.sql $blank_version");

        // If there isn't a conflict with this table, then move it to the merge location
        if (!in_array($table, $conflict)) {
          exec("mv $temp_version $merge_version");
        }
      }

      // Delete temp file
      if (file_exists("$blank_version")) exec("rm $blank_version");
    }

  }
  print "\n";

  // If there were conflicts, fail
  if (isset($conflict[0])) {
    print "\nDON'T PANIC! But, I'm afraid I have to inform you that the following tables\nfailed to merge:\n\n";
    print_r($conflict);
    print "\nPlease correct the conflicts in '$merge_location' (look for '<<<<<<<').\n";
    print "Afterwards, run '$script_path/merge.php continue' to finish the merge.\n\n";
    return;
  }

  } // end else of !$continue

  // MERGE COMPLETE

  // Copy this new merged version to all three branches
  exec("rm -r $dev_location $lastmerge_location $prod_location");
  exec("cp $tmpdev_location/table_list.txt $merge_location");
  exec("cp -R $merge_location $dev_location");
  exec("cp -R $merge_location $lastmerge_location");
  exec("cp -R $merge_location $prod_location");

  // Dev and last-merge do not need to be bothered with all the data
  $tables_cleared = dbscripts_process_tables($tmpdev_branch, array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2), FALSE);
  foreach ($tables_cleared as $table) {
    // Erase the data file
  	if (file_exists("$dev_location/data/$table.sql")) exec("rm $dev_location/data/$table.sql");
    if (file_exists("$lastmerge_location/data/$table.sql")) exec("rm $lastmerge_location/data/$table.sql");

    // Copy over the dev version of the table
    exec("cp $tmpdev_location/tables/$table.sql $dev_location/tables/$table.sql");
    exec("cp $tmpdev_location/tables/$table.sql $lastmerge_location/tables/$table.sql");
  }

  // Clear temp
  exec("rm -r $temp_location/*");

  return "\nMerge was successfull.\n\n";
}



/**
 * Process an array of tables
 *
 * When given an array of all tables, you can either remove matches
 * from the table list, or pick only positive matches
 *
 * @param $branch
 *    Which branch should be use for its list of tables
 * @param $tables_compare
 *    An array of table names that should be compared
 * @param $remove_match
 *    Should matches in $tables_compare be removed from the list, or kept
 */
function dbscripts_process_tables($branch, $tables_compare, $remove_match = TRUE) {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // Set location
  $branch_location = "$dump_path/$branch";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Check if the table list file exists, otherwise fail
  if (!file_exists("$branch_location/table_list.txt")) {
    return "The branch '$branch' does not have a table_list.txt file";
  }

  $tables = file("$branch_location/table_list.txt", FILE_IGNORE_NEW_LINES);
  $tables_match = array();

  foreach ($tables as $key => $table) {
    // Since some tables are specified with a .*, generating other possible values
    $truncated = explode('_', $table);
    $truncated1 = isset($truncated[0]) ? $truncated[0].'_.*' : '';
    $truncated2 = isset($truncated[1]) ? $truncated[0].'_'.$truncated[1].'_.*' : '';

    $check_tables = array($table, $truncated1, $truncated2);
    foreach ($check_tables as $check) {
      if (in_array($check, $tables_compare)) {
        $tables_match[$key] = $table;
      }
    }
  }

  foreach ($tables_match as $key => $table) {
    unset($tables[$key]);
  }

  if ($remove_match) {
    return $tables;
  } else {
    return $tables_match;
  }
}


/**
 * Get a given table's current auto increment value
 *
 * @param $table
 *    The table name you want to check
 * @param $branch
 *    The branch that will be checked, since each branch could
 *    possibly have a different increment.
 */
function dbscripts_get_table_increment($table, $branch) {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $branch_location = "$dump_path/$branch";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  $increment = FALSE;
  if(file_exists("$branch_location/tables/$table.sql")) {
    if (exec("grep 'auto_increment' $branch_location/tables/$table.sql")) {
      $inc_string = exec("grep 'AUTO_INCREMENT=' $branch_location/tables/$table.sql");

      $increment['num'] = '0';
      if ($inc_string) {
        $inc_string_parts = explode(' ', $inc_string);
        foreach ($inc_string_parts as $part) {
          if (strpos($part, 'AUTO_INCREMENT=') !== FALSE) {
            $increment['num'] = str_replace('AUTO_INCREMENT=', '', $part);
          }
        }
      }

      $id_string = exec("grep 'auto_increment' $branch_location/tables/$table.sql");
      $id_string_parts = explode('`', $id_string);
      $increment['id'] = $id_string_parts[1];
    }
  }

  return $increment;
}


/**
 * Get a list of all tables that are using auto increment
 *
 * @param $branch
 *    The branch that has the tables to check
 * @param $filter_option
 *    What degree of filtering should be done on the tables returned, just
 *    like when dumping and restoring.
 */
function dbscripts_find_tables_with_increment($branch, $filter_option = "full") {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // Set location
  $branch_location = "$dump_path/$branch";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Set the filtering options, ignoring tables not being tracked
  $tables_ignored = array();
  switch($filter_option){
    case 'none':
      break;

    case 'min':
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1);
      break;

    default:
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2);
      break;
  }

  $table_list = dbscripts_process_tables($branch, $tables_ignored);
  if (!is_array($table_list)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
    return $table_list;
  }

  $list = array();
  foreach ($table_list as $table) {
    $increment = dbscripts_get_table_increment($table, $branch);
    if ($increment && is_array($increment)) {
      $list[] = $table;
    } elseif ($increment != FALSE) {
      // If not FALSE and not an array, then fail and pass through the error message
    	return $increment;
    }
  }

  return $list;
}



/**
 * Return a table's primary key
 *
 * @param $table
 *   Table to check
 * @param $branch
 *   Branch to check in
 */
function dbscripts_get_table_primary_keys($table, $branch) {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // Set locations
  $branch_location = "$dump_path/$branch";

  if (file_exists("$branch_location/tables/$table.sql")) {
    $primary_key_line = exec("grep '^  PRIMARY KEY' $branch_location/tables/$table.sql | sed 's/`//g'");
    if ($primary_key_line) {
      $primary_key_line_parts = explode("(", $primary_key_line);
      $primary_key_line_parts = explode(")", $primary_key_line_parts[1]);
      $primary_keys = explode(",", $primary_key_line_parts[0]);
      return $primary_keys;
    }
  }

}



/**
 * Find all possible references for the given table
 *
 * Helper script to make it easier to discover if there are possible references
 * to a given table.
 *
 * DOES NOT GAURANTEE TO FIND ALL REFERENCES
 * This is merely a tool to assist you in narrowing down possibilities and provide a
 * first level of error checking for dbscripts_get_table_references.  It is your
 * responsibility to ensure all actual references are recorded in config.references.inc
 *
 * @param $table
 *    Table to find all references of
 * @param $branch
 *    Branch to check
 * @param $filter_option
 *    What degree of filtering should be done on the tables returned, just
 *    like when dumping and restoring.
 */
function dbscripts_find_possible_table_references($table, $branch, $filter_option = "full") {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // Set locations
  $branch_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Ensure tmp directory exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  // Set the filtering options, ignoring tables not being tracked
  $tables_ignored = array();
  switch($filter_option){
    case 'none':
      break;

    case 'min':
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1);
      break;

    default:
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2);
      break;
  }

  // List of tables to check
  $table_list = dbscripts_process_tables($branch, $tables_ignored);
  if (!is_array($table_list)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
    return $table_list;
  }

  // Get the id name of the table
  $increment = dbscripts_get_table_increment($table, $branch);
  if (!is_array($increment) && $increment != FALSE) {
    // If not FALSE and not an array, then fail and pass through the error message
  	return $increment;
  }
  $id = isset($increment['id']) ? $increment['id'] : FALSE;

  $list = array();
  if ($id) {
    foreach ($table_list as $check_table) {
      // Ensure this table doesn't use the same ID name for auto increment as well
      $match_increment = dbscripts_get_table_increment($check_table, $branch);
      if (!is_array($match_increment) && $match_increment != FALSE) {
        // If not FALSE and not an array, then fail and pass through the error message
        return $match_increment;
      }
      $match_id = isset($match_increment['id']) ?  $match_increment['id'] : FALSE;

    	exec("grep '^  `' $branch_location/tables/$check_table.sql > $temp_location/columns.sql");
      $columns = file("$temp_location/columns.sql", FILE_IGNORE_NEW_LINES);
      foreach ($columns as $column) {
      	$parts = explode('`', $column);
        // Avoid returning columns that are auto_increment on that table
        if (strpos($parts[1], $id) !== FALSE && $parts[1] != $match_id) {
          $list[$check_table][] = $parts[1];
        }
      }
      exec("rm $temp_location/columns.sql");
    }
  }

  return $list;
}


/**
 * Return actual references to a given table
 *
 * Checks against dbscripts_find_possible_table_references to ensure there are no
 * obvious tables that could have been missed during development.  Update settings
 * in config.reference.inc to reflect any new references and false positives.
 *
 * DOES NOT GUARANTEE TO RETURN ALL REFERENCES
 * It only returns what is configured in config.reference.inc, and checks that
 * configuration against dbscripts_find_possible_table_references for *possible*
 * matches that you may have missed during development.  It is your responcibility
 * to check the database schema for references (such as by checking the diff after
 * a change).
 *
 * @param $table
 *    Table to find all references of
 * @param $branch
 *    Branch to check
 * @param $filter_option
 *    What degree of filtering should be done on the tables returned, just
 *    like when dumping and restoring.
 */
function dbscripts_get_table_references($table, $branch, $filter_option = 'full', $error_check = TRUE) {
  require('config.inc');
  require('config.references.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";
  if (!isset($tables_referenced)) return "The file 'config.references.inc' does not exist.  Copy from the example version?";

  // Set locations
  $branch_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Ensure tmp directory exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  $increment = dbscripts_get_table_increment($table, $branch);
  if (!is_array($increment) && $increment != FALSE) {
    // If not FALSE and not an array, then fail and pass through the error message
    return $increment;
  }

  if (!in_array($table, $tables_standalone) && isset($increment)) {

    $config_references = isset($tables_referenced[$table]['references']) ? $tables_referenced[$table]['references'] : array();
    $config_false_positive = isset($tables_referenced[$table]['false positives']) ? $tables_referenced[$table]['false positives'] : array();

    // The table list file is important, so fail if it doesn't exist
    if (!file_exists("$branch_location/table_list.txt")) {
    	return "The branch '$branch' does not have a table_list.txt file";
    }

    $table_list = file("$branch_location/table_list.txt", FILE_IGNORE_NEW_LINES);

    // Since you can set the configuration with *'s, creating an array $references of real values
    $references = array();
    foreach ($table_list as $check_table) {
      // Format possible values for the table name
      $table_name_parts = explode("_", $check_table);
      $check_table_1 = isset($table_name_parts[1]) ? $table_name_parts[0]."_.*" : FALSE;
      $check_table_2 = isset($table_name_parts[2]) ? $table_name_parts[0]."_".$table_name_parts[1]."_.*" : FALSE;
      $check_table_3 = isset($table_name_parts[3]) ? $table_name_parts[0]."_".$table_name_parts[1]."_".$table_name_parts[2]."_.*" : FALSE;
      $possible_table_names = array($check_table, $check_table_1, $check_table_2, $check_table_3);

      // Check all possible values for the table name
      foreach ($possible_table_names as $check) {
        if ($check && (isset($config_references[$check]) || isset($config_false_positive[$check]))) {
          // Check to see if any of the configured column names for that table have a wildcard
          $wildcard = FALSE;
          if (isset($config_references[$check])) {
            foreach ($config_references[$check] as $column) {
              if (strpos($column, '*') !== FALSE) {
              	$wildcard = TRUE;
              }
            }
          }
          if (isset($config_false_positive[$check])) {
            foreach ($config_false_positive[$check] as $column) {
              if (strpos($column, '*') !== FALSE) {
                $wildcard = TRUE;
              }
            }
          }

          // If there is a wildcard, we need to find all possible matches in the table
          if ($wildcard) {
            // Get all columns for the given table
            exec("grep '^  `' $branch_location/tables/$check_table.sql > $temp_location/columns.sql");
            $column_values = file("$temp_location/columns.sql");

            // Check each column
            foreach ($column_values as $column_value) {
              // Extract the column name
            	$column_value_parts = explode('`', $column_value);
              $column_name = $column_value_parts[1];

              // Format other possible values for the column name
              $column_name_parts = explode("_", $column_name);
              $column_num_parts = count($column_name_parts);
              $column_last_part = $column_num_parts -1;
              $column_name_1 = isset($column_name_parts[1]) ? $column_name_parts[0]."_*" : FALSE;
              $column_name_2 = isset($column_name_parts[2]) ? $column_name_parts[0]."_*_".$column_name_parts[$column_last_part] : FALSE;
              $possible_column_names = array($column_name, $column_name_1, $column_name_2);

              // Check all the possible column names
              foreach ($possible_column_names as $possible_column_name) {
                if ($possible_column_name) {
                  if (isset($config_references[$check]) && in_array($possible_column_name, $config_references[$check])) {
                    $references['references'][$check_table][] = $column_name;
                  }
                  if (isset($config_false_positive[$check]) && in_array($possible_column_name, $config_false_positive[$check])) {
                    $references['false positives'][$check_table][] = $column_name;
                  }
                }
              }
            }

            // Erase the temporary file
            exec("rm $temp_location/columns.sql");

          } else {
          	// Without a wildcard as the column name we can just return what was configured
            if (isset($config_references[$check])) {
              $references['references'][$check_table] = $config_references[$check];
            }
            if (isset($config_false_positive[$check])) {
              $references['false positives'][$check_table] = $config_false_positive[$check];
            }
          }

        }
      }
    }

    // Now checking the real values against the discovered possible references
    if ($error_check) {
      $possible_references = dbscripts_find_possible_table_references($table, $branch, $filter_option);
      if(is_array($possible_references)) {
        foreach ($possible_references as $check_table => $check_ids) {
          foreach ($check_ids as $check_id) {

            // Check to see if the possible reference is in the references list as found above
            $check_references = isset($references['references'][$check_table]) ? in_array($check_id, $references['references'][$check_table]) : FALSE;
            $check_false_positive = isset($references['false positives'][$check_table]) ? in_array($check_id, $references['false positives'][$check_table]) : FALSE;

            // If it is not in either, then record it under 'found'
            if(!$check_references && !$check_false_positive) {
              $references['found'][$check_table][] = $check_id;
            }

          }
        }
      } else {
      	// If an array is not returned, then pass through the error message
        return $possible_references;
      }
    }

  }

  // Add itself as a reference
  $references['references'][$table][] = $increment['id'];

  return $references;
}



/**
 * Raise the increments of the given table within the given branch
 *
 * @param $table
 *   Table to raise the increments of
 * @param $column
 *   Column to raise the increments of
 * @param $start_at
 *   Range of increments within the table to start rewriting
 * @param $change_to
 *   Range to change rewrite the increments to.  Must be higher than both $start_at,
 *   and the table's current increment value.  If it is not, then it will be recalculated
 *   to be the highest value.
 * @param $branch
 *   Branch to make the changes on.
 */
function dbscripts_raise_table_increments($table, $start_at, $change_to, $branch, $filter_option = 'full') {
  require('config.inc');
  require('config.references.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version.";
  if (!isset($tables_referenced)) return "The file 'config.references.inc' does not exist.  Copy from the example version.";

  // Set locations
  $branch_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Check if the table exists, otherwise fail
  if (!file_exists("$branch_location/tables/$table.sql")) {
    return "The table '$table' does not exist";
  }

  // Ensure tmp directory exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  // Find the largest increment value between $change_to and the current
  // increment. Use the highest increment
  $current_inc = dbscripts_get_table_increment($table, $branch);
  if (is_array($current_inc) && $current_inc['num'] > $change_to) {
    $change_to = $current_inc['num'];
  }

  // Get an array of the range of increments to work with
  if ($start_at < $current_inc['num']) {
    $increment_range = range($start_at, ($current_inc['num'] - 1));
  } else {
    // There is nothing to do then.  Likely there are no new records.
    return;
  }

  // Create a key=>value array of increment pairs
  $increment_pairs = array();
  $increment_change = $change_to;
  foreach ($increment_range as $increment) {
    $increment_pairs[$increment] = $increment_change;
    $increment_change++;
  }

  // If there is a system paths reference, also add the pairs
  $pattern_pair_old = array();
  $pattern_pair_new = array();
  if (isset($system_paths[$table])) {
    $i = 0;
    foreach ($system_paths[$table]['patterns'] as $key => $pattern) {
      foreach ($increment_pairs as $old_increment => $new_increment) {
        $pattern_pair_old[$i] = str_replace('*', $old_increment, $pattern);
        $pattern_pair_new[$i] = str_replace('*', $new_increment, $pattern);
        $i++;
      }
    }
  }

  // Write these increment and pattern pairs to a file for awk to use
  exec("echo '#!/usr/bin/awk -f' > $temp_location/increment_pairs.awk");
  exec("echo '{' >> $temp_location/increment_pairs.awk");
  foreach ($increment_pairs as $increment => $target) {
    exec("echo 'increment_pairs[$increment] = $target' >> $temp_location/increment_pairs.awk");
  }
  foreach ($pattern_pair_old as $key => $pattern) {
    exec("echo \"pattern_pair_old[$key] = \\\"'$pattern'\\\"\" >> $temp_location/increment_pairs.awk");
  }
  foreach ($pattern_pair_new as $key => $pattern) {
    exec("echo \"pattern_pair_new[$key] = \\\"'$pattern'\\\"\" >> $temp_location/increment_pairs.awk");
  }
  exec("echo '}' >> $temp_location/increment_pairs.awk");

  // Find all tables that use the increment
  $table_references = dbscripts_get_table_references($table, $branch, $filter_option);
  if (!is_array($table_references)) {
    return "\nERROR: ".$table_references."\n\n";
  }

  // Fail if there are any found possible references
  if (isset($table_references['found'])) {
    return "/nFAILED:  Possible references found/n/n".$table_references['found']."\n";
  }

  // Add system path patterns as references
  if (isset($system_paths[$table]['tables'])) {
    foreach ($system_paths[$table]['tables'] as $system_path_table => $system_path_columns) {
      foreach ($system_path_columns as $system_path_column) {
        $table_references['references'][$system_path_table][] = $system_path_column;
      }
    }
  }

  // Raise the auto_increment value of the table
  exec("sed 's/ AUTO_INCREMENT={$current_inc['num']} / AUTO_INCREMENT={$increment_change} /g' $branch_location/tables/$table.sql > $temp_location/$table.sql");
  exec("mv $temp_location/$table.sql $branch_location/tables/$table.sql");

  // For all references, raise the increment
  foreach ($table_references['references'] as $table_to_modify => $columns_referenced) {

    // Check if this table exists and has any data stored
    if (
          file_exists("$branch_location/tables/$table_to_modify.sql") &&
          (
            file_exists("$branch_location/data/$table_to_modify.sql") ||
            file_exists("$branch_location/data/$table_to_modify-new.sql")
          )
        ) {

      // Create an array of the files we'll be working with (existing data and/or new data)
      $file_names = array();
      if (file_exists("$branch_location/data/$table_to_modify.sql")) {
        $file_names[] = $table_to_modify;
      }
      if (file_exists("$branch_location/data/$table_to_modify-new.sql")) {
        $file_names[] = $table_to_modify."-new";
      }

      // Create a CSV version of the table's data
      foreach ($file_names as $file_name) {
        exec("
            grep 'INSERT INTO' $branch_location/data/$file_name.sql \\
            |sed -e 's/^INSERT INTO `$table_to_modify` VALUES (//g' -e 's/);$//g' \\
            |sed -e 's/#/#PND#/g' -e \"s/\\\\\'/#SQ#/g\" -e 's/\"/#DQ#/g' \\
            > $temp_location/$file_name.csv
        ");
      }

      // Create an array of the table's structure
      exec("grep '^  `' $branch_location/tables/$table_to_modify.sql > $temp_location/$table_to_modify.txt");
      $table_columns = file("$temp_location/$table_to_modify.txt", FILE_IGNORE_NEW_LINES);
      exec("rm $temp_location/$table_to_modify.txt");

      // Find out the column position
      $column_positions = array();
      foreach ($columns_referenced as $column_to_modify) {
        $found_position = FALSE;
        foreach ($table_columns as $key => $table_column) {
          if (strpos($table_column, "`$column_to_modify`")) {
            $column_positions[] = $key;
            $found_position = TRUE;
          }
        }
        if (!$found_position) {
          return "ERROR: Didn't find column '$column_to_modify' in '$table_to_modify' when I thought I should have.";
        }
      }

      // Set the column positions as a variable for awk
      $column_variables = '';
      foreach ($column_positions as $position) {
        $column_variables .= "\ncolumns_to_change[$position] = $position\n";
      }
      exec("echo '#!/usr/bin/awk -f' > $temp_location/columns.awk");
      exec("echo '{".$column_variables."}' >> $temp_location/columns.awk");

      // Raise the increments in the csv version of the data
      foreach ($file_names as $file_name) {
        exec("
            cat $temp_location/$file_name.csv | \\
            awk -f $script_path/csv.awk -f $temp_location/increment_pairs.awk -f $temp_location/columns.awk -f $script_path/change_column_values.awk | \\
            sed -e 's/,$//g' \\
            > $temp_location/$file_name-tmp.csv
        ");

        // Check if there were any errors
        if (exec("grep '^ERROR' $temp_location/$file_name-tmp.csv")) {
          return "ERROR: There was an error parsing the data in '$table_to_modify' as CSV.  Check the file '$temp_location/$file_name-tmp.csv'";
        } else {
          exec("mv $temp_location/$file_name-tmp.csv $temp_location/$file_name.csv");
        }
      }

      // Delete variable temp file
      exec("rm $temp_location/columns.awk");

      // Convert the csv file back to SQL
      foreach ($file_names as $file_name) {
        $sql = file("$branch_location/data/$file_name.sql", FILE_IGNORE_NEW_LINES);

        // Get all the top sql comments
        $data_start = FALSE;
        foreach ($sql as $key => $line) {
          if ($data_start === FALSE) {
            if (preg_match("/^INSERT INTO/", $line)){
              $data_start = $key;
            } else{
              $line = str_replace("'", "#SQ#", $line); // issues with quotes
              if ($key == 0) {
                exec("echo '$line' > $temp_location/$file_name.sql");
              } else {
                exec("echo '$line' >> $temp_location/$file_name.sql");
              }
            }
          }
        }

        // Reapply quotes to the top comments
        exec("sed \"s/#SQ#/'/g\" $temp_location/$file_name.sql > $temp_location/$file_name-tmp.sql");
        exec("mv $temp_location/$file_name-tmp.sql $temp_location/$file_name.sql");

        // Apply the new data after the top sql comments, converting the csv to sql along the way
        exec("
          sed -e 's/^/INSERT INTO `$table_to_modify` VALUES (/g' -e 's/$/);/g' \\
          -e 's/#DQ#/\"/g' -e \"s/#SQ#/\\\\\'/g\" -e 's/#PND#/#/g' \\
          $temp_location/$file_name.csv >> $temp_location/$file_name.sql
        ");

        // Create a file of the bottom comments
        foreach ($sql as $key => $line) {
          if ($key > $data_start && !preg_match("/^INSERT INTO/", $line)) {
            $line = str_replace("'", "#SQ#", $line); // issues with quotes
            exec("echo '$line' >> $temp_location/$file_name-bottom.sql");
          }
        }

        // Reapply quotes to the bottom comments
        // (seperating sed statements to avoid running another sed query through the entire data)
        exec("sed \"s/#SQ#/'/g\" $temp_location/$file_name-bottom.sql > $temp_location/$file_name-tmp.sql");

        // Attach the bottom comments to the end of the sql file
        exec("cat $temp_location/$file_name-tmp.sql >> $temp_location/$file_name.sql");

        // Delete the temporary files
        exec("rm $temp_location/$file_name.csv");
        exec("rm $temp_location/$file_name-bottom.sql");
        exec("rm $temp_location/$file_name-tmp.sql");
      }

    }
  }

  // Delete temporary file
  exec("rm $temp_location/increment_pairs.awk");

  // Since we got this far without error, we can now move
  // all the newly created sql files from temp back to the branch
  foreach ($table_references['references'] as $table_to_modify => $columns_referenced) {
    if (file_exists("$temp_location/$table_to_modify.sql")) {
      exec("mv $temp_location/$table_to_modify.sql $branch_location/data/$table_to_modify.sql");
    }
    if (file_exists("$temp_location/$table_to_modify-new.sql")) {
      exec("mv $temp_location/$table_to_modify-new.sql $branch_location/data/$table_to_modify-new.sql");
    }
  }

}



/**
 * Raise all increments of a given branch based on the values of the last-merge and
 * production branches
 *
 * @param $dev_branch
 *   Location of the branch you wish to make the changes on.  All actions will effect
 *   and modify this branch.
 * @param $lastmerge_branch
 *   Location of the branch that was used to represent the state the
 *   last time the other two branches were merged.  This is used as reference
 *   to discover the start of increment rewriting.
 * @param $prod_branch
 *   Location of the branch that will be used as reference to discover at which point
 *   the rewrite should start at.
 */
function dbscripts_raise_all_increments($dev_branch = 'development', $lastmerge_branch = 'last-merge', $prod_branch = 'production') {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // If empty data gets sent through, reset it to defaults
  if (!$dev_branch) $dev_branch = 'development';
  if (!$lastmerge_branch) $lastmerge_branch = 'last-merge';
  if (!$prod_branch) $prod_branch = 'production';

  // Set all locations
  $temp_location = "$dump_path/tmp";
  $dev_location = "$dump_path/$dev_branch";
  $lastmerge_location = "$dump_path/$lastmerge_branch";
  $prod_location = "$dump_path/$prod_branch";

  // Ensure all the branches exist
  $missing_branch = '';
  if (!file_exists($dev_location)) $missing_branch .= $dev_branch.' ';
  if (!file_exists($lastmerge_location)) $missing_branch .= $lastmerge_branch.' ';
  if (!file_exists($prod_location)) $missing_branch .= $prod_branch.' ';

  // Cancel merge if all branches do not exist
  if ($missing_branch) {
    return "\nMissing database files for merge: $missing_branch\n\n";
  }

  // Ensure tmp folder exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  // Define the tables, fail if they don't return arrays
  if (file_exists("$dev_location/table_list.txt")) {
    $tables = file("$dev_location/table_list.txt", FILE_IGNORE_NEW_LINES);
  } else {
    return "\nFAILED: Cannot find $dev_location/table_list.txt";
  }

  foreach ($tables as $table) {
    // Find the last-merge value
    $lastmerge_increment = dbscripts_get_table_increment($table, $lastmerge_branch);
    $start_at = $lastmerge_increment['num'];

    // Find the production value
    $production_increment = dbscripts_get_table_increment($table, $prod_branch);
    $change_to = $production_increment['num'];

    if ($start_at < $change_to) {
      // Raise the increments
      dbscripts_raise_table_increments($table, $start_at, $change_to, $dev_branch);
    }
  }

}



/**
 * Return help for each script
 *
 * @param $script
 *   Available options are 'dump', 'restore', 'erase' and 'merge'.
 */
function dbscripts_help($script) {
  require('config.inc');
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  switch ($script) {

    // Dump help
    case 'dump':
      $help = <<<EOF

NAME
    Dump - database dump script

SYNOPSIS
    dump.php [branch] [filter-option]

EXAMPLE USAGE
    development: dump.php
    production:  dump.php production min
    last merge:  dump.php last-merge

DESCRIPTION
    Dump the database from MySQL to a given branch of dump files.  The dump is
    'diffable' allowing it to be under version control.  Filtering options are
    performed to avoid dumping data that is not nessisary to be stored from
    development and production environments.

OPTIONS
    branch
        Branch the database should be dumped to.  Default options are
        'development', 'production' and 'last-merge'.  Other naming patterns
        may be used if you wish to dump the database to an alternate location.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    filter-option
        The level of filtering that should be performed during the dump.
            full
                Removes the full option of data from the dump.  Most useful for
                removing user, sessions and cache data.  Recomended to be used
                when dumping a development database
            min
                Removes only a select minimum of data from the dump.  Most
                useful for removing sessions and cache data.  Recommended to be
                used when dumping a production database.
            none
                NO filtering is performed whatsoever.  The entire database is
                dumped to the given file.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    dump documentation
        http://drupal.org/node/232153

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    // Restore help
    case 'restore':
      $help = <<<EOF

NAME
    Restore - database restore script

SYNOPSIS
    restore.php [branch] [filter-option]

EXAMPLE USAGE
    development: restore.php
    production:  restore.php production min
    last merge:  restore.php last-merge

DESCRIPTION
    Restores the database from a given branch.  Filtering options are performed
    to prevent certain data from being lost in the MySQL database in
    development and production environments.  Also performs the 'erase' script
    to ensure that any tables removed in development are removed when performing
    a restore.

OPTIONS
    branch
        The branch the database should be restored from.  Default options are
        'development', 'production' and 'last-merge'.  Other naming patterns
        may be used if you wish to restore the database from an alternate branch.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    filter-option
        The level of filtering that should be performed during the restore to
        allow some data to be preserved in the MySQL database.
            full
                Preserves the full option of data currently residing within the
                MySQL database.  Most useful for preserving user, sessions and
                cache data.  Recommended to use this when restoring within a
                development environment.
            min
                Preserves only a select minimum of data currently residing
                within the MySQL database.  Most useful for preserving sessions
                and cache data.  Recommended to use this when restoring within a
                production environment.
            none
                NO filtering is performed whatsoever.  The entire database is
                erased from MySQL and restored with only the data from the given
                file.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    restore and erase documentation
        http://drupal.org/node/232154

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    // Erase help
    case 'erase':
      $help = <<<EOF

NAME
  Erase - database erase script

SYNOPSIS
  erase.php [filter-option]

EXAMPLE USAGE
    development: erase.php
    production:  erase.php min

DESCRIPTION
    Erases the database within the MySQL database.  Filtering options are
    performed to prevent erasing data that should be kept.

OPTIONS
    filter-option
        The level of filtering that shold be performed during the erasure.
            full
                Preserves the full option of data within the MySQL database.
                Most useful for keeping user, sessions and cache data.
                Recommended to be used when erasing within a development
                environment.
            min
                Preserves only the select minimum of data within the MySQL
                database.  Most useful for preserving sessions data so you do
                not get logged out.  Recommended to be used when erasing within
                a production environment.
            none
                NO filtering is performed whatsoever.  The entire database will
                be erased.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    restore and erase documentation
        http://drupal.org/node/232154

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    case 'merge':
      $help = <<<EOF

NAME
    Merge - database merge script

SYNOPSIS
    merge.php [dev-branch] [last-merge-branch] [prod-branch]

EXAMPLE USAGE
    default: merge.php

DESCRIPTION
    Merge a development and production database together.

OPTIONS
    dev-branch
        The location of the database branch used for development.  Only configuration
        and content changes will be preserved from this file.  All user data
        will be lost.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    last-merge-branch
        The location of the database branch that was used to represent the state
        the last time both production development were merged.  This is
        important to be able to track the difference between an addition and a
        subtraction.
        Relative to: {$file_path}
        Defaults to: {$file_path}/last-merge

    prod-branch
        The location of the database branch used for production.  Only content and
        user data will be preserved from this branch.  All other data will be
        lost.
        Relative to: {$file_path}
        defaults to: {$file_path}/production

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    merge documentation
        http://drupal.org/node/232155

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

// TODO: Write help for "find"
    case 'find':
      $help = <<<EOF

NAME
    Find - Search for information within the database


\n
EOF;
      break;

    default:
      $help = 'That is not a valid script.'."\n";
      break;
  }

  return $help;
}
