<?php

/**
  TODO

  Readjust working space sequences to latest dev snapshot

  Merge content as normal
  Restore&Dump only modified/merged tables
    check diff, and flag to be restored and dumped
    (Double check if this is still nessisary if data files are seperate)

  Have script to complete merge process after conflict (merge.php finish)
**/


/**
 * Get the database connection settings from settings.php file
 */
function dbscripts_db_connect() {
  require('config.inc');
  require("$settings_path/settings.php");

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";
  if (!isset($db_url)) return "The file 'settings.php' file does not exist.";

  preg_match('/'.$dbtype.':\/\/([^:]+):([^@]+)@([^\/]+)\/(.+)/', $db_url, $db_settings);

  if (empty($db_settings)) {
    return FALSE;
  } else {

    $dbuser = $db_settings[1];
    $dbpassword = $db_settings[2];
    $dbhost = $db_settings[3];
    $dbname = $db_settings[4];

    return "-u $dbuser -p$dbpassword -h $dbhost $dbname";
  }
}


/**
 * Get options for dump file and filtering
 *
 * @param $argv
 *   Pass in the $_SERVER['argv'] variable to return options set when running
 *   the script.
 */
function dbscripts_get_options($argv) {
  $use_default = FALSE;
  if(isset($argv[1])) {
    if(in_array($argv[1],array('min','none','full'))) {
      $use_default = TRUE;
    }
  } else {
    $use_default = TRUE;
  }

  if ($use_default) {
    $options['file'] = 'development';
    $filter_options = isset($argv[1]) ? $argv[1] : '';
  } else {
    $options['file'] = $argv[1];
    $filter_options = isset($argv[2]) ? $argv[2] : '';
  }

  switch ($filter_options) {
    case 'min':
    $options['filter'] = 'min';
      break;

    case 'none':
      $options['filter'] = 'none';
      break;

    default:
      $options['filter'] = 'full';
      break;
  }

  return $options;
}


/**
 * Dump the database
 *
 * @param $branch
 *   Branch that the database should be dumped to.  Defaults to 'development'.
 *   Alternative options that are supported by default are 'production' and
 *   'last-merge'.  Other string patterns may be used if you wish to dump the
 *   the database to an alternate location.
 * @param $filter_option
 *   Choose what level of filtering should be performed during the dump.  Filter
 *   levels are configured in config.inc
 *   'full' - Default option.  Removes the full option of data from the dump.
 *       Most useful for removing user, sessions and cache data.  Use this when
 *       dumping a development database.
 *   'min' - Removes only a select minimum of data from the dump.  Most useful
 *       for removing sessions and cache data.  Use this when dumping a
 *       production database.
 *   'none' - NO filtering is performed whatsoever.  The entire database is
 *       dumped.
 */
function dbscripts_dump($branch = 'development', $filter_option = 'full') {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
  }

  $dump_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";
  $workspace_location = "$dump_path/workspace/last-dump";

  // Creating required folders
  if (!file_exists($temp_location)) {exec("mkdir -p $temp_location");}
  if (!file_exists("$dump_location/data")) {exec("mkdir -p $dump_location/data");}
  if (!file_exists("$dump_location/tables")) {exec("mkdir -p $dump_location/tables");}
  if (!file_exists("$workspace_location/tables")) {exec("mkdir -p $workspace_location/tables");}
  if (!file_exists("$workspace_location/data")) {exec("mkdir -p $workspace_location/data");}

  // Set the filtering options and message to be presented to the user
  $tables_cleared = array();
  switch($filter_option){
    case 'none':
      $message = "Performed a full database dump to $branch.";
      break;

    case 'min':
      $tables_cleared = array_merge($tables_filtered, $tables_filtered_l1);
      $message = "Dumped the database to $branch with minimal filtering.";
      break;

    default:
      $tables_cleared = array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2);
      $message = "Dumped the database to $branch with full filtering options.";
      break;
  }

  // Create an array of all tables in the database and store it
  exec("$mysqldump --add-drop-table --no-data $db_connection_settings | grep 'DROP TABLE' | sed -e \"s/DROP TABLE IF EXISTS .//g\" -e \"s/.;//g\" > $workspace_location/table_list.txt");
  $table_list = file("$workspace_location/table_list.txt", FILE_IGNORE_NEW_LINES);

  // These are all the special dump options that make the database diffable
  // and preserve character set
  $dump_options = "--skip-opt --add-drop-table --add-locks --create-options --quick --lock-tables --set-charset --disable-keys --order-by-primary --skip-comments --comments=FALSE --default-character-set=utf8 --character-sets-dir=$charsets --hex-blob";

  // Dump the structure of all tables
  if (exec("ls $temp_location")) exec("rm -r $temp_location/*");
  foreach ($table_list as $table) {
  	exec("$mysqldump $dump_options --no-data $db_connection_settings --tables $table > $temp_location/$table.sql");
  }

  // Check that a file actually has data, and stop if it doesn't
  if (file_get_contents("$temp_location/$table_list[0].sql") == '') {
    exec("rm $temp_location/*");
    return "\nEmpty data returned.  There may be a problem connecting to the database.\n\n";
  }

  // Move the table files to the working space's last dump
  if (exec("ls $workspace_location/tables")) exec("rm $workspace_location/tables/*");
  exec("mv $temp_location/* $workspace_location/tables");

  // Get tables to be dumped by removing $tables_cleared from the list of all tables
  $tables_dumped = dbscripts_process_tables("workspace/last-dump", $tables_cleared);
  if (!is_array($tables_dumped)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
    return "\n$tables_dumped\n\n";
  }

  // Dump the data of all tables we're tracking
  foreach ($tables_dumped as $table) {
    // get the table's increment both currently, and last-merge and compare
    $increment_current = dbscripts_get_table_increment($table, 'workspace/last-dump');
    $increment_lastmerge = dbscripts_get_table_increment($table, 'last-merge');

    $new_data = FALSE;
    if ($increment_current && is_array($increment_current) && $increment_lastmerge && is_array($increment_lastmerge)) {
      if ($increment_current['num'] > $increment_lastmerge['num']) {
      	$new_data = TRUE;
      } elseif ($increment_current['num'] < $increment_lastmerge['num']) {
      	$message .= "\n\nWARNING: Current AUTO_INCREMENT of table $table is lower than last-merge\n\n";
      }
    }

    if ($new_data) {
      exec("$mysqldump $dump_options --no-create-info $db_connection_settings --where='{$increment_lastmerge['id']}<{$increment_lastmerge['num']}' --tables $table > $temp_location/$table.sql");
      exec("$mysqldump $dump_options --no-create-info $db_connection_settings --where='{$increment_lastmerge['id']}>={$increment_lastmerge['num']}' --tables $table > $temp_location/$table-new.sql");
    } else {
      exec("$mysqldump $dump_options --no-create-info $db_connection_settings --tables $table > $temp_location/$table.sql");
    }

    // If there's no data, then delete the file
    if (!exec("grep 'INSERT INTO' $temp_location/$table.sql")) {exec("rm $temp_location/$table.sql");}
    if (file_exists("$temp_location/$table-new.sql")) {
      if (!exec("grep 'INSERT INTO' $temp_location/$table-new.sql")) exec("rm $temp_location/$table-new.sql");
    }
  }

  // Move the data files to the working space's last dump
  if (exec("ls $workspace_location/data")) exec("rm $workspace_location/data/*");
  exec("mv $temp_location/* $workspace_location/data");

  // For now we're just going to directly copy everything to $dump_location
  exec("rm -r $dump_location/*");
  exec("cp -R $workspace_location/* $dump_location");


  // Let the user know what happened
  return "\n$message\n\n";
}


/**
 * Erase the database
 *
 * @param $filter_option
 *   Choose what level of filtering should be performed while erasing the
 *   database.  Filter levels are configured in config.inc.  Any options set to
 *   be filtered will be subsequently PRESERVED in the database, and not erased.
 *   'full' - Default option.  Preserves the full option of data from the dump.
 *       Most useful for keeping user, sessions and cache data.  Use this when
 *       erasing a development database.
 *   'min' - Preserves only a select minimum of data from the dump.  Most useful
 *       for keeping sessions data so you don't get logged out.  Use this when
 *       erasing a production database.
 *   'none' - NO filtering is performed whatsoever.  The entire database will be
 *       erased.
 */
function dbscripts_erase($filter_option = 'full') {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
  }

  // Set the filtering options and message to be presented to the user
  $tables_preserved = array();
  switch ($filter_option) {
    case 'none';
      $message = "Erased the entire database.";
      break;

    case 'min':
      $tables_preserved = $tables_filtered_l1;
      $message = "Erased the database, except for minimal preserved tables.";
      break;

    default:
      $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
      $message = "Erased the database, except for preserved tables.";
      break;
  }

  $filter = '';
  foreach($tables_preserved as $preserved_data) {
    $filter .= "|grep -v 'DROP TABLE IF EXISTS .$preserved_data.;'";
  }

  // Dump options to make it easy to erase the database
  $dump_options = "--add-drop-table --no-data";

  // We'll dump the database, perform some changes to it, then pipe it back into
  // MySQL so it will drop the given tables
  exec("$mysqldump $dump_options $db_connection_settings | grep 'DROP TABLE' $filter | $mysql $db_connection_settings");

  return "\n$message\n\n";
}


/**
 * Restore the database
 *
 * @param $branch
 *   File the database should be restored from.  Defaults to 'development'.
 *   Alternative options that are supported by default are 'production' and
 *   'last-merge'.  Other filename patterns may be used if you wish to restore
 *   the database from an alternate location.
 * @param $filter_option
 *   Choose what level of filtering should be performed during the restoration.
 *   Filter levels are configured in config.inc
 *   'full' - Default option.  Preserves the full option of data currently
 *       residing within MySQL. Most useful for preserving user, sessions and
 *       cache data.  Use this when restoring within a development environment.
 *   'min' - Preserves only a select minimum of data currently residing within
 *       MySQL.  Most useful for preserving sessions and cache data.  Use this
 *       when restoring within a production environment.
 *   'none' - NO filtering is performed whatsoever.  The entire database is
 *       erased from MySQL and restored with the data from the given file.
 */
function dbscripts_restore($branch = 'development', $filter_option = 'full') {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
  }

  // Set locations
  $dump_location = "$dump_path/$branch";
  $workspace_location = "$dump_path/workspace/last-restore";

  // Check that the requested location exists
  if (!file_exists($dump_location)) {return "\nThe path does not exist: $dump_location\n\n";}
  if (!file_exists($workspace_location)) {exec("mkdir -p $workspace_location");}

  // Set behavior depending on filter
  $tables_preserved = array();
  switch($filter_option){
    case 'none':
      $message = "Restored the full database";
      break;

    case 'min':
      $tables_preserved = $tables_filtered_l1;
      $message = "Restored the database perserving minimal tables";
      break;

    default:
      $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
      $message = "Restored the database preserving the full option of tables";
      break;
  }

  // Erase the database so any tables that were removed stay removed
  dbscripts_erase($filter_option);

  // Get a list of tables to restore by removing $tables_preserved from the list of all tables
  $tables_restored = dbscripts_process_tables($branch, $tables_preserved);
  if (!is_array($tables_restored)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
  	return "\n$tables_restored\n\n";
  }

  // Restore each database file
  foreach ($tables_restored as $table) {
    if (file_exists("$dump_location/tables/$table.sql")) exec("$mysql $db_connection_settings < $dump_location/tables/$table.sql");
    if (file_exists("$dump_location/data/$table.sql")) exec("$mysql $db_connection_settings < $dump_location/data/$table.sql");
    if (file_exists("$dump_location/data/$table-new.sql")) exec("$mysql $db_connection_settings < $dump_location/data/$table-new.sql");
  }

  // Move what was restored to the working space
  if (exec("ls $workspace_location")) {exec("rm -r $workspace_location/*");}
  exec("cp -R $dump_location/* $workspace_location");

  return "\n$message\n\n";
}


/**
 * Merge databases
 *
 * You really only need to set the following parameters for expert use.
 * Otherwise this function can be run with no options.
 *
 * @param $dev_branch
 *   Location of the database file that was used for 'development'.  Only
 *   configuration and content changes will be preserved.  All user data will
 *   be lost.
 * @param $lastmerge_branch
 *   Location of the database file that was used to represent the state the
 *   last time both production and development were merged.  This is important
 *   to be able to track the difference between an addition and a subtraction.
 * @param $prod_branch
 *   Location of the database file that is used as 'production'.  Only content
 *   and user data will be perserved.  All other data will be lost.
 */
function dbscripts_merge($dev_branch = 'development', $lastmerge_branch = 'last-merge', $prod_branch = 'production') {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $message = "WARNING: This merge only merges tables, not data\n\n";

  // If empty data gets sent through, reset it to defaults
  if (!$dev_branch) $dev_branch = 'development';
  if (!$lastmerge_branch) $lastmerge_branch = 'last-merge';
  if (!$prod_branch) $prod_branch = 'production';

  // Set all locations
  $temp_location = "$dump_path/tmp";
  $dev_location = "$dump_path/$dev_branch";
  $lastmerge_location = "$dump_path/$lastmerge_branch";
  $prod_location = "$dump_path/$prod_branch";
  $merge_location = "$temp_location/merge";
  $process_merge_location = "$temp_location/processing";
  $process_increment_location = "$temp_location/increment";

  // Ensure all the branches exist
  $missing_branch = '';
  if (!file_exists($dev_location)) $missing_branch .= $dev_branch.' ';
  if (!file_exists($lastmerge_location)) $missing_branch .= $lastmerge_branch.' ';
  if (!file_exists($prod_location)) $missing_branch .= $prod_branch.' ';

  // Cancel merge if all branches do not exist
  if ($missing_branch) {
    return "\nMissing database files for merge: $missing_branch\n\n";
  }

  // Ensure tmp folder exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  // After a conflict, the temp files would still exist, so delete them
  if (exec("ls $temp_location")) exec("rm -r $temp_location/*");

  // Creating merge folders
  if (!file_exists($merge_location)) exec("mkdir -p $merge_location/tables $merge_location/data");
  if (!file_exists($process_merge_location)) exec("mkdir -p $process_location");
  if (!file_exists($process_increment_location)) exec("mkdir -p $process_location");

  // Define the tables, fail if they don't return arrays
  $tables_content = dbscripts_process_tables($dev_branch, $tables_merge, FALSE);
  if (!is_array($tables_content)) {
  	return "\n$tables_content\n\n";
  }
  $tables_prod = dbscripts_process_tables($prod_branch, $tables_override, FALSE);
  if (!is_array($tables_prod)) {
    return "\n$tables_prod\n\n";
  }
  $tables_dev = dbscripts_process_tables($dev_branch, array_merge($tables_merge, $tables_override));
  if (!is_array($tables_dev)) {
    return "\n$tables_dev\n\n";
  }

  // Move all development tables and data to the temp merge location
  foreach ($tables_dev as $table) {
  	if (file_exists("$dev_location/tables/$table.sql")) exec("cp $dev_location/tables/$table.sql $merge_location/tables");
    if (file_exists("$dev_location/data/$table.sql")) exec("cp $dev_location/data/$table.sql $merge_location/data");
    if (file_exists("$dev_location/data/$table-new.sql")) exec("cp $dev_location/data/$table-new.sql $merge_location/data");
  }

  // Move all the production tables and data to the temp merge location
  foreach ($tables_prod as $table) {
    if (file_exists("$prod_location/tables/$table.sql")) exec("cp $prod_location/tables/$table.sql $merge_location/tables");
    if (file_exists("$prod_location/data/$table.sql")) exec("cp $prod_location/data/$table.sql $merge_location/data");
    if (file_exists("$prod_location/data/$table-new.sql")) exec("cp $prod_location/data/$table-new.sql $merge_location/data");
  }

  // DATA MERGING
  // Now here's the hard part: Merge the data from development into the production values

  // Copy all tables to processing locations
  foreach ($tables_content as $table) {
    // Copy development structure to final merge location
    if (file_exists("$dev_location/tables/$table.sql")) exec("cp $dev_location/tables/$table.sql $merge_location/tables");

    // Copy production's new data to final merge location
    if (file_exists("$prod_location/data/$table-new.sql")) exec("cp $prod_location/data/$table-new.sql $merge_location/tables/$table-new_prod.sql");

    // Copy development data to have their increments processed
    if (file_exists("$dev_location/data/$table.sql")) exec("cp $dev_location/data/$table.sql $process_increment_location/tables");
    if (file_exists("$dev_location/data/$table-new.sql")) exec("cp $dev_location/data/$table-new.sql $process_increment_location/tables");
  }

  // Raise all the increments on development's new data to be above production values
  foreach ($tables_content as $table) {
    // TODO
  }

  // Merge existing data
  $conflict = '';
  foreach ($tables_content as $table) {
    // Set data paths
    $dev_version = "$process_sequences_location/$table.sql";
    $lastmerge_version = "$lastmerge_location/data/$table.sql";
    $prod_version = "$prod_location/data/$table.sql";

    // Merge the existing data, and put it in the tables to process
    // Don't need to check if the branches exist... already checked above
    exec("diff3 -E --merge $dev_version $lastmerge_version $prod_version > $process_merge_location/$table.sql");
    $check_conflict = exec("grep '^<<<<<<<' $process_merge_location/$table.sql");
    if ($check_conflict) {
       // If there is a conflict, leave the file where it is
       $conflict .= $table."\n";
    } else {
      // If it merged successfully, move the file to the final merge location
    	exec("mv $process_merge_location/$table.sql $merge_location/data/$table.sql");
    }
   }

  // If there were conflicts, fail
  if ($conflict) {
    return "\nWARNING: The following tables failed to merge:\n\n $conflict\n";
  }

  // MERGE COMPLETE
  // Copy this new merged version to all three branches
  exec("rm $dev_location/tables/* $dev_location/data/* $lastmerge_location/tables/* $lastmerge_location/data/* $prod_location/tables/* $prod_location/data/*");
  exec("cp $merge_location/tables/* $dev_location/tables");
  exec("cp $merge_location/tables/* $lastmerge_location/tables");
  exec("cp $merge_location/tables/* $prod_location/tables");
  exec("cp $merge_location/data/* $prod_location/data");

  // Dev and last-merge do not need to be bothered with all the data
  $tables_dev_data = dbscripts_process_tables($dev_branch, array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2));
  if (!is_array($tables_dev_data)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
    return "\n$tables_dev_data\n\n";
  }
  foreach ($tables_dev_data as $table) {
  	if (file_exists("$merge_location/data/$table.sql")) exec("cp $merge_location/data/$table.sql $dev_location/data");
  }
  exec("cp $dev_location/data/* $lastmerge_location/data");

  $message .= "Merge was successfull.";

  // Clear temp
  exec("rm -r $temp_location/*");

  return "\n$message\n\n";
}


/**
 * Process an array of tables
 *
 * When given an array of all tables, you can either remove matches
 * from the table list, or pick only positive matches
 *
 * @param $branch
 *    Which branch should be use for its list of tables
 * @param $tables_compare
 *    An array of table names that should be compared
 * @param $remove_match
 *    Should matches in $tables_compare be removed from the list, or kept
 */
function dbscripts_process_tables($branch, $tables_compare, $remove_match = TRUE) {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // Set location
  $branch_location = "$dump_path/$branch";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Check if the table list file exists, otherwise fail
  if (!file_exists("$branch_location/table_list.txt")) {
    return "The branch '$branch' does not have a table_list.txt file";
  }

  $tables = file("$branch_location/table_list.txt", FILE_IGNORE_NEW_LINES);
  $tables_match = array();

  foreach ($tables as $key => $table) {
    // Since some tables are specified with a .*, generating other possible values
    $truncated = explode('_', $table);
    $truncated1 = isset($truncated[0]) ? $truncated[0].'_.*' : '';
    $truncated2 = isset($truncated[1]) ? $truncated[0].'_'.$truncated[1].'_.*' : '';

    $check_tables = array($table, $truncated1, $truncated2);
    foreach ($check_tables as $check) {
      if (in_array($check, $tables_compare)) {
        $tables_match[$key] = $table;
      }
    }
  }

  foreach ($tables_match as $key => $table) {
    unset($tables[$key]);
  }

  if ($remove_match) {
    return $tables;
  } else {
    return $tables_match;
  }
}


/**
 * Get a given table's current auto increment value
 *
 * @param $table
 *    The table name you want to check
 * @param $branch
 *    The branch that will be checked, since each branch could
 *    possibly have a different increment.
 */
function dbscripts_get_table_increment($table, $branch) {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  $branch_location = "$dump_path/$branch";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  $increment = FALSE;
  if(file_exists("$branch_location/tables/$table.sql")) {
    if (exec("grep 'auto_increment' $branch_location/tables/$table.sql")) {
      $inc_string = exec("grep 'AUTO_INCREMENT=' $branch_location/tables/$table.sql");

      $increment['num'] = '0';
      if ($inc_string) {
        $inc_string_parts = explode(' ', $inc_string);
        foreach ($inc_string_parts as $part) {
          if (strpos($part, 'AUTO_INCREMENT=') !== FALSE) {
            $increment['num'] = str_replace('AUTO_INCREMENT=', '', $part);
          }
        }
      }

      $id_string = exec("grep 'auto_increment' $branch_location/tables/$table.sql");
      $id_string_parts = explode('`', $id_string);
      $increment['id'] = $id_string_parts[1];
    }
  }

  return $increment;
}


/**
 * Get a list of all tables that are using auto increment
 *
 * @param $branch
 *    The branch that has the tables to check
 * @param $filter_option
 *    What degree of filtering should be done on the tables returned, just
 *    like when dumping and restoring.
 */
function dbscripts_find_tables_with_increment($branch, $filter_option = "full") {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // Set location
  $branch_location = "$dump_path/$branch";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Set the filtering options, ignoring tables not being tracked
  $tables_ignored = array();
  switch($filter_option){
    case 'none':
      break;

    case 'min':
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1);
      break;

    default:
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2);
      break;
  }

  $table_list = dbscripts_process_tables($branch, $tables_ignored);
  if (!is_array($table_list)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
    return $table_list;
  }

  $list = array();
  foreach ($table_list as $table) {
    $increment = dbscripts_get_table_increment($table, $branch);
    if ($increment && is_array($increment)) {
      $list[] = $table;
    } elseif ($increment != FALSE) {
      // If not FALSE and not an array, then fail and pass through the error message
    	return $increment;
    }
  }

  return $list;
}


/**
 * Find all possible references for the given table
 *
 * Helper script to make it easier to discover if there are possible references
 * to a given table.
 *
 * DOES NOT GAURANTEE TO FIND ALL REFERENCES
 * This is merely a tool to assist you in narrowing down possibilities and provide a
 * first level of error checking for dbscripts_get_table_references.  It is your
 * responsibility to ensure all actual references are recorded in config.references.inc
 *
 * @param $table
 *    Table to find all references of
 * @param $branch
 *    Branch to check
 * @param $filter_option
 *    What degree of filtering should be done on the tables returned, just
 *    like when dumping and restoring.
 */
function dbscripts_find_possible_table_references($table, $branch, $filter_option = "full") {
  require('config.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  // Set locations
  $branch_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Ensure tmp directory exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  // Set the filtering options, ignoring tables not being tracked
  $tables_ignored = array();
  switch($filter_option){
    case 'none':
      break;

    case 'min':
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1);
      break;

    default:
      $tables_ignored = array_merge($tables_filtered, $tables_filtered_l1, $tables_filtered_l2);
      break;
  }

  // List of tables to check
  $table_list = dbscripts_process_tables($branch, $tables_ignored);
  if (!is_array($table_list)) {
    // Fail and pass through the message from dbscripts_process_tables if it didn't pass an array
    return $table_list;
  }

  // Get the id name of the table
  $increment = dbscripts_get_table_increment($table, $branch);
  if (!is_array($increment) && $increment != FALSE) {
    // If not FALSE and not an array, then fail and pass through the error message
  	return $increment;
  }
  $id = isset($increment['id']) ? $increment['id'] : FALSE;

  $list = array();
  if ($id) {
    foreach ($table_list as $check_table) {
      // Ensure this table doesn't use the same ID name for auto increment as well
      $match_increment = dbscripts_get_table_increment($check_table, $branch);
      if (!is_array($match_increment) && $match_increment != FALSE) {
        // If not FALSE and not an array, then fail and pass through the error message
        return $match_increment;
      }
      $match_id = isset($match_increment['id']) ?  $match_increment['id'] : FALSE;

    	exec("grep '^  `' $branch_location/tables/$check_table.sql > $temp_location/columns.sql");
      $columns = file("$temp_location/columns.sql", FILE_IGNORE_NEW_LINES);
      foreach ($columns as $column) {
      	$parts = explode('`', $column);
        // Avoid returning columns that are auto_increment on that table
        if (strpos($parts[1], $id) !== FALSE && $parts[1] != $match_id) {
          $list[$check_table][] = $parts[1];
        }
      }
      exec("rm $temp_location/columns.sql");
    }
  }

  return $list;
}


/**
 * Return actual references to a given table
 *
 * Checks against dbscripts_find_possible_table_references to ensure there are no
 * obvious tables that could have been missed during development.  Update settings
 * in config.reference.inc to reflect any new references and false positives.
 *
 * DOES NOT GUARANTEE TO RETURN ALL REFERENCES
 * It only returns what is configured in config.reference.inc, and checks that
 * configuration against dbscripts_find_possible_table_references for *possible*
 * matches that you may have missed during development.  It is your responcibility
 * to check the database schema for references (such as by checking the diff after
 * a change).
 *
 * @param $table
 *    Table to find all references of
 * @param $branch
 *    Branch to check
 * @param $filter_option
 *    What degree of filtering should be done on the tables returned, just
 *    like when dumping and restoring.
 */
function dbscripts_get_table_references($table, $branch, $filter_option = 'full') {
  require('config.inc');
  require('config.references.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";
  if (!isset($tables_referenced)) return "The file 'config.references.inc' does not exist.  Copy from the example version?";

  // Set locations
  $branch_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Ensure tmp directory exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  $increment = dbscripts_get_table_increment($table, $branch);
  if (!is_array($increment) && $increment != FALSE) {
    // If not FALSE and not an array, then fail and pass through the error message
    return $increment;
  }

  if (!in_array($table, $tables_standalone) && isset($increment)) {

    $config_references = isset($tables_referenced[$table]['references']) ? $tables_referenced[$table]['references'] : array();
    $config_false_positive = isset($tables_referenced[$table]['false positives']) ? $tables_referenced[$table]['false positives'] : array();

    // The table list file is important, so fail if it doesn't exist
    if (!file_exists("$branch_location/table_list.txt")) {
    	return "The branch '$branch' does not have a table_list.txt file";
    }

    $table_list = file("$branch_location/table_list.txt", FILE_IGNORE_NEW_LINES);

    // Since you can set the configuration with *'s, creating an array $references of real values
    $references = array();
    foreach ($table_list as $check_table) {
      // Format possible values for the table name
      $table_name_parts = explode("_", $check_table);
      $check_table_1 = isset($table_name_parts[1]) ? $table_name_parts[0]."_.*" : FALSE;
      $check_table_2 = isset($table_name_parts[2]) ? $table_name_parts[0]."_".$table_name_parts[1]."_.*" : FALSE;
      $check_table_3 = isset($table_name_parts[3]) ? $table_name_parts[0]."_".$table_name_parts[1]."_".$table_name_parts[2]."_.*" : FALSE;
      $possible_table_names = array($check_table, $check_table_1, $check_table_2, $check_table_3);

      // Check all possible values for the table name
      foreach ($possible_table_names as $check) {
        if ($check && (isset($config_references[$check]) || isset($config_false_positive[$check]))) {
          // Check to see if any of the configured column names for that table have a wildcard
          $wildcard = FALSE;
          if (isset($config_references[$check])) {
            foreach ($config_references[$check] as $column) {
              if (strpos($column, '*') !== FALSE) {
              	$wildcard = TRUE;
              }
            }
          }
          if (isset($config_false_positive[$check])) {
            foreach ($config_false_positive[$check] as $column) {
              if (strpos($column, '*') !== FALSE) {
                $wildcard = TRUE;
              }
            }
          }

          // If there is a wildcard, we need to find all possible matches in the table
          if ($wildcard) {
            // Get all columns for the given table
            exec("grep '^  `' $branch_location/tables/$check_table.sql > $temp_location/columns.sql");
            $column_values = file("$temp_location/columns.sql");

            // Check each column
            foreach ($column_values as $column_value) {
              // Extract the column name
            	$column_value_parts = explode('`', $column_value);
              $column_name = $column_value_parts[1];

              // Format other possible values for the column name
              $column_name_parts = explode("_", $column_name);
              $column_num_parts = count($column_name_parts);
              $column_last_part = $column_num_parts -1;
              $column_name_1 = isset($column_name_parts[1]) ? $column_name_parts[0]."_*" : FALSE;
              $column_name_2 = isset($column_name_parts[2]) ? $column_name_parts[0]."_*_".$column_name_parts[$column_last_part] : FALSE;
              $possible_column_names = array($column_name, $column_name_1, $column_name_2);

              // Check all the possible column names
              foreach ($possible_column_names as $possible_column_name) {
                if ($possible_column_name) {
                  if (isset($config_references[$check]) && in_array($possible_column_name, $config_references[$check])) {
                    $references['references'][$check_table][] = $column_name;
                  }
                  if (isset($config_false_positive[$check]) && in_array($possible_column_name, $config_false_positive[$check])) {
                    $references['false positives'][$check_table][] = $column_name;
                  }
                }
              }
            }

            // Erase the temporary file
            exec("rm $temp_location/columns.sql");

          } else {
          	// Without a wildcard as the column name we can just return what was configured
            if (isset($config_references[$check])) {
              $references['references'][$check_table] = $config_references[$check];
            }
            if (isset($config_false_positive[$check])) {
              $references['false positives'][$check_table] = $config_false_positive[$check];
            }
          }

        }
      }
    }

    // Now checking the real values against the discovered possible references
    $possible_references = dbscripts_find_possible_table_references($table, $branch, $filter_option);
    if(is_array($possible_references)) {
      foreach ($possible_references as $check_table => $check_ids) {
        foreach ($check_ids as $check_id) {

          // Check to see if the possible reference is in the references list as found above
          $check_references = isset($references['references'][$check_table]) ? in_array($check_id, $references['references'][$check_table]) : FALSE;
          $check_false_positive = isset($references['false positives'][$check_table]) ? in_array($check_id, $references['false positives'][$check_table]) : FALSE;

          // If it is not in either, then record it under 'found'
          if(!$check_references && !$check_false_positive) {
            $references['found'][$check_table][] = $check_id;
          }

        }
      }
    } else {
    	// If an array is not returned, then pass through the error message
      return $possible_references;
    }

  }

  // Add itself as a reference
  $references['references'][$table][] = $increment['id'];

  return $references;
}



/**
 * Raise the increments of the given table within the given branch
 *
 * @param $table
 *   Table to raise the increments of
 * @param $column
 *   Column to raise the increments of
 * @param $start_at
 *   Range of increments within the table to start rewriting
 * @param $change_to
 *   Range to change rewrite the increments to.  Must be higher than both $start_at,
 *   and the table's current increment value.  If it is not, then it will be recalculated
 *   to be the highest value.
 * @param $branch
 *   Branch to make the changes on.
 */
function dbscripts_raise_increments($table, $column, $start_at, $change_to, $branch, $filter_option = 'full') {
  require('config.inc');
  require('config.references.inc');

  // Ensure required files are loaded
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version.";
  if (!isset($tables_referenced)) return "The file 'config.references.inc' does not exist.  Copy from the example version.";

  // Set locations
  $branch_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";

  // Check if the branch exists, otherwise fail
  if (!file_exists($branch_location)) {
    return "The branch '$branch' does not exist";
  }

  // Check if the table exists, otherwise fail
  if (!file_exists("$branch_location/tables/$table.sql")) {
    return "The table '$table' does not exist";
  }

  // Ensure tmp directory exists
  if (!file_exists($temp_location)) exec("mkdir -p $temp_location");

  // Find the largest increment value between $start_at, $change_to and the current
  // increment. Use the highest increment
  $current_inc = dbscripts_get_table_increment($table, $branch);
  if (is_array($current_inc) && $current_inc['num'] > $change_to) {
    $change_to = $current_inc;
  }
  if ($start_at > $change_to) {
    $change_to = $start_at++;
  }

  // Get an array of the range of increments to work with
  $increment_range = range($start_at, ($current_inc['num'] - 1));

  // Find all tables that use the increment
  $table_references = dbscripts_get_table_references($table, $branch, $filter_option);
  if (!is_array($table_references)) {
    return "\nERROR: ".$table_references."\n\n";
  }

  // Fail if there are any found possible references
  if (isset($table_references['found'])) {
    return "/nFAILED:  Possible references found/n/n".$table_references['found']."\n";
  }

  // For all references, raise the increment
  foreach ($table_references['references'] as $table_to_modify => $columns_referenced) {
    $file_names = array();

    // Check if this table exists and has any data stored
    if (
          file_exists("$branch_location/tables/$table_to_modify.sql") &&
          (
            file_exists("$branch_location/data/$table_to_modify.sql") ||
            file_exists("$branch_location/data/$table_to_modify-new.sql")
          )
        ) {

      // Create an array of the files we'll be working with (existing data and/or new data)
      if (file_exists("$branch_location/data/$table_to_modify.sql")) {
        $file_names[] = $table_to_modify;
      }
      if (file_exists("$branch_location/data/$table_to_modify-new.sql")) {
        $file_names[] = $table_to_modify."-new";
      }

      // Create a CSV version of the table's data
      foreach ($file_names as $file_name) {
        exec("
            grep 'INSERT INTO' $branch_location/data/$file_name.sql \\
            |sed -e 's/^INSERT INTO `$table_to_modify` VALUES (//g' -e 's/);$//g' \\
            > $temp_location/$file_name.csv
        ");
      }

      // Create an array of the table's structure
      exec("grep '^  `' $branch_location/tables/$table_to_modify.sql > $temp_location/$table_to_modify.txt");
      $table_columns = file("$temp_location/$table_to_modify.txt", FILE_IGNORE_NEW_LINES);
      exec("rm $temp_location/$table_to_modify.txt");

      foreach ($columns_referenced as $column_to_modify) {
        // Find out the column position
        $column_position = FALSE;
        foreach ($table_columns as $key => $table_column) {
          if (strpos($table_column, "`$column_to_modify`")) {
            $column_position = $key;
          }
        }
        if ($column_position === FALSE) {
          return "ERROR: Didn't find column '$column_to_modify' in '$table_to_modify' when I thought I should have.";
        }

        // Raise all the increments within the given range
        $increment_to_change = $start_at;
        $new_increment_value = $change_to;
        $variables = '';
        foreach ($increment_range as $increment) {
          $variables = "-v column=$column_position -v increment_to_change=$increment_to_change -v new_increment_value=$new_increment_value";

          // Raise the increments in the csv version of the data
          foreach ($file_names as $file_name) {
            exec("
                cat $temp_location/$file_name.csv | \\
                sed \"s/\\\\\'/###@@###/g\" | \\
                awk $variables -f $script_path/csv.awk -f $script_path/change_column_values.awk | \\
                sed -e \"s/###@@###/\\\\\'/g\" -e 's/,$//g' \\
                > $temp_location/$file_name-tmp.csv
            ");

            // Check if there were any errors
            if (exec("grep '^ERROR' $temp_location/$file_name-tmp.csv")) {
              return "ERROR: There was an error parsing the data in '$table_to_modify' as CSV.  Check the file '$temp_location/$file_name-tmp.csv'";
            } else {
              exec("mv $temp_location/$file_name-tmp.csv $temp_location/$file_name.csv");
            }
          }

          // Raise increments for next pass
          $increment_to_change++;
          $new_increment_value++;
        }
      }

      // Convert the csv file back to SQL
      foreach ($file_names as $file_name) {
        $sql = file("$branch_location/data/$file_name.sql", FILE_IGNORE_NEW_LINES);

        // Get all the top sql comments
        $data_start = FALSE;
        foreach ($sql as $key => $line) {
          if ($data_start === FALSE) {
            if (preg_match("/^INSERT INTO/", $line)){
              $data_start = $key;
            } else{
              $line = str_replace("'", "###@@###", $line); // issues with quotes
              if ($key == 0) {
                exec("echo '$line' > $temp_location/$file_name.sql");
              } else {
                exec("echo '$line' >> $temp_location/$file_name.sql");
              }
            }
          }
        }

        // Apply the new data after the top sql comments, converting the csv to sql along the way
        exec("sed -e 's/^/INSERT INTO `$table_to_modify` VALUES (/g' -e 's/$/);/g' $temp_location/$file_name.csv >> $temp_location/$file_name.sql");

        // Apply the bottom comments after the new data
        foreach ($sql as $key => $line) {
          if ($key > $data_start && !preg_match("/^INSERT INTO/", $line)) {
            $line = str_replace("'", "###@@###", $line); // issues with quotes
            exec("echo '$line' >> $temp_location/$file_name.sql");
          }
        }

        // Reapply quotes
        exec("sed \"s/###@@###/'/g\" $temp_location/$file_name.sql > $temp_location/$file_name-tmp.sql");
        exec("mv $temp_location/$file_name-tmp.sql $temp_location/$file_name.sql");

        // Delete the temporary csv file
        exec("rm $temp_location/$file_name.csv");
      }

    }
  }

  // Since we got this far without error, we can now move
  // all the newly created sql files from temp back to the branch
  foreach ($table_references['references'] as $table_to_modify => $columns_referenced) {
    if (file_exists("$temp_location/$table_to_modify.sql")) {
      exec("mv $temp_location/$table_to_modify.sql $branch_location/data/$table_to_modify.sql");
    }
    if (file_exists("$temp_location/$table_to_modify-new.sql")) {
      exec("mv $temp_location/$table_to_modify-new.sql $branch_location/data/$table_to_modify-new.sql");
    }
  }

}


/**
 * Return help for each script
 *
 * @param $script
 *   Available options are 'dump', 'restore', 'erase' and 'merge'.
 */
function dbscripts_help($script) {
  require('config.inc');
  if (!isset($dump_path)) return "The file 'config.inc' does not exist.  Copy from the example version?";

  switch ($script) {

    // Dump help
    case 'dump':
      $help = <<<EOF

NAME
    Dump - database dump script

SYNOPSIS
    dump.php [branch] [filter-option]

EXAMPLE USAGE
    development: dump.php
    production:  dump.php production min
    last merge:  dump.php last-merge

DESCRIPTION
    Dump the database from MySQL to a given branch of dump files.  The dump is
    'diffable' allowing it to be under version control.  Filtering options are
    performed to avoid dumping data that is not nessisary to be stored from
    development and production environments.

OPTIONS
    branch
        Branch the database should be dumped to.  Default options are
        'development', 'production' and 'last-merge'.  Other naming patterns
        may be used if you wish to dump the database to an alternate location.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    filter-option
        The level of filtering that should be performed during the dump.
            full
                Removes the full option of data from the dump.  Most useful for
                removing user, sessions and cache data.  Recomended to be used
                when dumping a development database
            min
                Removes only a select minimum of data from the dump.  Most
                useful for removing sessions and cache data.  Recommended to be
                used when dumping a production database.
            none
                NO filtering is performed whatsoever.  The entire database is
                dumped to the given file.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    dump documentation
        http://drupal.org/node/232153

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    // Restore help
    case 'restore':
      $help = <<<EOF

NAME
    Restore - database restore script

SYNOPSIS
    restore.php [branch] [filter-option]

EXAMPLE USAGE
    development: restore.php
    production:  restore.php production min
    last merge:  restore.php last-merge

DESCRIPTION
    Restores the database from a given branch.  Filtering options are performed
    to prevent certain data from being lost in the MySQL database in
    development and production environments.  Also performs the 'erase' script
    to ensure that any tables removed in development are removed when performing
    a restore.

OPTIONS
    branch
        The branch the database should be restored from.  Default options are
        'development', 'production' and 'last-merge'.  Other naming patterns
        may be used if you wish to restore the database from an alternate branch.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    filter-option
        The level of filtering that should be performed during the restore to
        allow some data to be preserved in the MySQL database.
            full
                Preserves the full option of data currently residing within the
                MySQL database.  Most useful for preserving user, sessions and
                cache data.  Recommended to use this when restoring within a
                development environment.
            min
                Preserves only a select minimum of data currently residing
                within the MySQL database.  Most useful for preserving sessions
                and cache data.  Recommended to use this when restoring within a
                production environment.
            none
                NO filtering is performed whatsoever.  The entire database is
                erased from MySQL and restored with only the data from the given
                file.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    restore and erase documentation
        http://drupal.org/node/232154

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    // Erase help
    case 'erase':
      $help = <<<EOF

NAME
  Erase - database erase script

SYNOPSIS
  erase.php [filter-option]

EXAMPLE USAGE
    development: erase.php
    production:  erase.php min

DESCRIPTION
    Erases the database within the MySQL database.  Filtering options are
    performed to prevent erasing data that should be kept.

OPTIONS
    filter-option
        The level of filtering that shold be performed during the erasure.
            full
                Preserves the full option of data within the MySQL database.
                Most useful for keeping user, sessions and cache data.
                Recommended to be used when erasing within a development
                environment.
            min
                Preserves only the select minimum of data within the MySQL
                database.  Most useful for preserving sessions data so you do
                not get logged out.  Recommended to be used when erasing within
                a production environment.
            none
                NO filtering is performed whatsoever.  The entire database will
                be erased.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    restore and erase documentation
        http://drupal.org/node/232154

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    case 'merge':
      $help = <<<EOF

NAME
    Merge - database merge script

SYNOPSIS
    merge.php [dev-branch] [last-merge-branch] [prod-branch]

EXAMPLE USAGE
    default: merge.php

DESCRIPTION
    Merge a development and production database together.

OPTIONS
    dev-branch
        The location of the database branch used for development.  Only configuration
        and content changes will be preserved from this file.  All user data
        will be lost.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    last-merge-branch
        The location of the database branch that was used to represent the state
        the last time both production development were merged.  This is
        important to be able to track the difference between an addition and a
        subtraction.
        Relative to: {$file_path}
        Defaults to: {$file_path}/last-merge

    prod-branch
        The location of the database branch used for production.  Only content and
        user data will be preserved from this branch.  All other data will be
        lost.
        Relative to: {$file_path}
        defaults to: {$file_path}/production

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    merge documentation
        http://drupal.org/node/232155

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

// TODO: Write help for "find"
    case 'find':
      $help = <<<EOF

NAME
    Find - Search for information within the database


\n
EOF;
      break;

    default:
      $help = 'That is not a valid script.'."\n";
      break;
  }

  return $help;
}
