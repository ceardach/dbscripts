<?php

/**
  TODO

  Dump each table's schema as a file (table_name_schema)
  Dump each table's data as a file (table_name_data)
  Have flag to dump as single file, or restore from single file

  Have a config setting to store sequences seperately by user
  Grab sequences as last line of file?
  Check if table auto increments next highest

  Merge by copying schema and data files for non-merge content
  Merge content as normal
  Restore&Dump only modified/merged tables
    check diff, and flag to be restored and dumped
    (Double check if this is still nessisary if data files are seperate)

  Have script to complete merge process after conflict (merge.php finish)
**/

/**
 * Get the database connection settings from settings.php file
 */
function dbscripts_db_connect() {
  require('config.inc');
  require("$settings_path/settings.php");

  preg_match('/'.$dbtype.':\/\/([^:]+):([^@]+)@([^\/]+)\/(.+)/', $db_url, $db_settings);

  if (empty($db_settings)) {
    return FALSE;
  } else {

    $dbuser = $db_settings[1];
    $dbpassword = $db_settings[2];
    $dbhost = $db_settings[3];
    $dbname = $db_settings[4];

    return "-u $dbuser -p$dbpassword -h $dbhost $dbname";
  }
}


/**
 * Get options for dump file and filtering
 *
 * @param $argv
 *   Pass in the $_SERVER['argv'] variable to return options set when running
 *   the script.
 */
function dbscripts_get_options($argv) {
  $use_default = FALSE;
  if(isset($argv[1])) {
    if(in_array($argv[1],array('min','none','full'))) {
      $use_default = TRUE;
    }
  } else {
    $use_default = TRUE;
  }

  if ($use_default) {
    $options['file'] = 'development';
    $filter_options = isset($argv[1]) ? $argv[1] : '';
  } else {
    $options['file'] = $argv[1];
    $filter_options = isset($argv[2]) ? $argv[2] : '';
  }

  switch ($filter_options) {
    case 'min':
    $options['filter'] = 'min';
      break;

    case 'none':
      $options['filter'] = 'none';
      break;

    default:
      $options['filter'] = 'full';
      break;
  }

  return $options;
}


/**
 * Return help for each script
 *
 * @param $script
 *   Available options are 'dump', 'restore', 'erase' and 'merge'.
 */
function dbscripts_help($script) {
  require('config.inc');

  switch ($script) {

    // Dump help
    case 'dump':
      $help = <<<EOF

NAME
    Dump - database dump script

SYNOPSIS
    dump.php [branch] [filter-option]

EXAMPLE USAGE
    development: dump.php
    production:  dump.php production min
    last merge:  dump.php last-merge

DESCRIPTION
    Dump the database from MySQL to a given branch of dump files.  The dump is
    'diffable' allowing it to be under version control.  Filtering options are
    performed to avoid dumping data that is not nessisary to be stored from
    development and production environments.

OPTIONS
    branch
        Branch the database should be dumped to.  Default options are
        'development', 'production' and 'last-merge'.  Other naming patterns
        may be used if you wish to dump the database to an alternate location.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    filter-option
        The level of filtering that should be performed during the dump.
            full
                Removes the full option of data from the dump.  Most useful for
                removing user, sessions and cache data.  Recomended to be used
                when dumping a development database
            min
                Removes only a select minimum of data from the dump.  Most
                useful for removing sessions and cache data.  Recommended to be
                used when dumping a production database.
            none
                NO filtering is performed whatsoever.  The entire database is
                dumped to the given file.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    dump documentation
        http://drupal.org/node/232153

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    // Restore help
    case 'restore':
      $help = <<<EOF

NAME
    Restore - database restore script

SYNOPSIS
    restore.php [branch] [filter-option]

EXAMPLE USAGE
    development: restore.php
    production:  restore.php production min
    last merge:  restore.php last-merge

DESCRIPTION
    Restores the database from a given branch.  Filtering options are performed
    to prevent certain data from being lost in the MySQL database in
    development and production environments.  Also performs the 'erase' script
    to ensure that any tables removed in development are removed when performing
    a restore.

OPTIONS
    branch
        The branch the database should be restored from.  Default options are
        'development', 'production' and 'last-merge'.  Other naming patterns
        may be used if you wish to restore the database from an alternate branch.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    filter-option
        The level of filtering that should be performed during the restore to
        allow some data to be preserved in the MySQL database.
            full
                Preserves the full option of data currently residing within the
                MySQL database.  Most useful for preserving user, sessions and
                cache data.  Recommended to use this when restoring within a
                development environment.
            min
                Preserves only a select minimum of data currently residing
                within the MySQL database.  Most useful for preserving sessions
                and cache data.  Recommended to use this when restoring within a
                production environment.
            none
                NO filtering is performed whatsoever.  The entire database is
                erased from MySQL and restored with only the data from the given
                file.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    restore and erase documentation
        http://drupal.org/node/232154

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    // Erase help
    case 'erase':
      $help = <<<EOF

NAME
  Erase - database erase script

SYNOPSIS
  erase.php [filter-option]

EXAMPLE USAGE
    development: erase.php
    production:  erase.php min

DESCRIPTION
    Erases the database within the MySQL database.  Filtering options are
    performed to prevent erasing data that should be kept.

OPTIONS
    filter-option
        The level of filtering that shold be performed during the erasure.
            full
                Preserves the full option of data within the MySQL database.
                Most useful for keeping user, sessions and cache data.
                Recommended to be used when erasing within a development
                environment.
            min
                Preserves only the select minimum of data within the MySQL
                database.  Most useful for preserving sessions data so you do
                not get logged out.  Recommended to be used when erasing within
                a production environment.
            none
                NO filtering is performed whatsoever.  The entire database will
                be erased.
        Defaults to: full

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    restore and erase documentation
        http://drupal.org/node/232154

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    case 'merge':
      $help = <<<EOF

NAME
    Merge - database merge script

SYNOPSIS
    merge.php [dev-branch] [last-merge-branch] [prod-branch]

EXAMPLE USAGE
    default: merge.php

DESCRIPTION
    Merge a development and production database together.

OPTIONS
    dev-branch
        The location of the database branch used for development.  Only configuration
        and content changes will be preserved from this file.  All user data
        will be lost.
        Relative to: {$file_path}
        Defaults to: {$file_path}/development

    last-merge-branch
        The location of the database branch that was used to represent the state
        the last time both production development were merged.  This is
        important to be able to track the difference between an addition and a
        subtraction.
        Relative to: {$file_path}
        Defaults to: {$file_path}/last-merge

    prod-branch
        The location of the database branch used for production.  Only content and
        user data will be preserved from this branch.  All other data will be
        lost.
        Relative to: {$file_path}
        defaults to: {$file_path}/production

FILES
    {$script_path}/config.inc
        Configuration settings for customizing these scripts for your
        environment.

AUTHOR
    Kathleen Murtagh <kathleen@ceardach.com>
        http://drupal.org/user/79082

SEE ALSO
    dbscripts documentation
        http://drupal.org/node/232151
    merge documentation
        http://drupal.org/node/232155

    Online ocumentation is not up-to-date for the 2.x version
\n
EOF;
      break;

    default:
      $help = 'That is not a valid script.'."\n";
      break;
  }

  return $help;
}


/**
 * Dump the database
 *
 * @param $branch
 *   Branch that the database should be dumped to.  Defaults to 'development'.
 *   Alternative options that are supported by default are 'production' and
 *   'last-merge'.  Other string patterns may be used if you wish to dump the
 *   the database to an alternate location.
 * @param $filter_option
 *   Choose what level of filtering should be performed during the dump.  Filter
 *   levels are configured in config.inc
 *   'full' - Default option.  Removes the full option of data from the dump.
 *       Most useful for removing user, sessions and cache data.  Use this when
 *       dumping a development database.
 *   'min' - Removes only a select minimum of data from the dump.  Most useful
 *       for removing sessions and cache data.  Use this when dumping a
 *       production database.
 *   'none' - NO filtering is performed whatsoever.  The entire database is
 *       dumped.
 */
function dbscripts_dump($branch = 'development', $filter_option = 'full') {
  require('config.inc');

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
    exit;
  }

  $dump_location = "$dump_path/$branch";
  $temp_location = "$dump_path/tmp";

  // Creating required folders
  if (!file_exists($temp_location)) {exec("mkdir -p $temp_location");}
  if (!file_exists($dump_location)) {exec("mkdir -p $dump_location");}
  if (!file_exists("$dump_location/data")) {exec("mkdir -p $dump_location/data");}
  if (!file_exists("$dump_location/tables")) {exec("mkdir -p $dump_location/tables");}

  // Create an array of all tables in the database and store it
  exec("$mysqldump --add-drop-table --no-data $db_connection_settings | grep 'DROP TABLE' | sed -e \"s/DROP TABLE IF EXISTS .//g\" -e \"s/.;//g\" > $dump_location/table_list.txt");
  $table_list = file("$dump_location/table_list.txt", FILE_IGNORE_NEW_LINES);

  // Set the filtering options and message to be presented to the user
  $tables_cleared = array();
  $tables_preserved = array();
  switch($filter_option){
    case 'none':
      $message = "Performed a full database dump to $branch.";
      break;

    case 'min':
      $tables_cleared = $tables_filtered;
      $tables_preserved = $tables_filtered_l1;
      $message = "Dumped the database to $branch with minimal filtering.";
      break;

    default:
      $tables_cleared = $tables_filtered;
      $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
      $message = "Dumped the database to $branch with full filtering options.";
      break;
  }

  // get an array of tables that don't have special treatment
  $special_tables = array_merge($tables_cleared,$tables_preserved);
  $tables_dumped = $table_list;
  foreach ($tables_dumped as $key => $table) {
    // Since some tables are specified with a *, generating other possible values
    $truncated = explode('_', $table);
    $truncated1 = isset($truncated[0]) ? $truncated[0].'_.*' : '';
    $truncated2 = isset($truncated[1]) ? $truncated[1].'_.*' : '';

    $check_tables = array($table, $truncated1, $truncated2);
    foreach ($check_tables as $check) {
      if (in_array($check,$special_tables)) {
        unset($tables_dumped[$key]); // remove the table if it exists in $special_tables
      }
    }

  }

  // These are all the special dump options that make the database diffable
  // and preserve character set
  $dump_options = "--skip-opt --add-drop-table --add-locks --create-options --quick --lock-tables --set-charset --disable-keys --order-by-primary --skip-comments --comments=FALSE --default-character-set=utf8 --character-sets-dir=$charsets --hex-blob";

  // Dump the structure of all tables
  if (exec("ls $temp_location")) exec("rm $temp_location/*");
  foreach ($table_list as $table) {
    $filter ='';
    if (in_array($table,$tables_preserved)) {
    	$filter = "|grep -v 'DROP TABLE IF EXISTS' |sed 's/CREATE TABLE/CREATE TABLE IF NOT EXISTS/g'";
    }
  	exec("$mysqldump $dump_options --no-data $db_connection_settings --tables $table $filter > $temp_location/$table.sql");
  }

  // Check that a file actually has data, and stop if it doesn't
  if (file_get_contents("$temp_location/$table_list[0].sql") == '') {
    print "\nEmpty data returned.  There may be a problem connecting to the database.\n\n";
    exec("rm $temp_location/*");
    exit;
  }

  // Move the table files from the temp directory
  if (exec("ls $dump_location/tables")) exec("rm $dump_location/tables/*");
  exec("mv $temp_location/* $dump_location/tables");

  // Dump the data of all tables we're tracking
  foreach ($tables_dumped as $table) {
    exec("$mysqldump $dump_options --no-create-info $db_connection_settings --tables $table > $temp_location/$table.sql");

    // if there's no data, then delete the file
    $data = exec("grep 'INSERT INTO' $temp_location/$table.sql");
    if (!$data) {exec("rm $temp_location/$table.sql");}
  }

  // Move the data files from the temp directory
  if (exec("ls $dump_location/data")) exec("rm $dump_location/data/*");
  exec("mv $temp_location/* $dump_location/data");

  // let the user know what happened
  return "\n$message\n\n";
}


/**
 * Erase the database
 *
 * @param $filter_option
 *   Choose what level of filtering should be performed while erasing the
 *   database.  Filter levels are configured in config.inc.  Any options set to
 *   be filtered will be subsequently PRESERVED in the database, and not erased.
 *   'full' - Default option.  Preserves the full option of data from the dump.
 *       Most useful for keeping user, sessions and cache data.  Use this when
 *       erasing a development database.
 *   'min' - Preserves only a select minimum of data from the dump.  Most useful
 *       for keeping sessions data so you don't get logged out.  Use this when
 *       erasing a production database.
 *   'none' - NO filtering is performed whatsoever.  The entire database will be
 *       erased.
 */
function dbscripts_erase($filter_option = 'full') {
  require('config.inc');

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
    exit;
  }

  // Set the filtering options and message to be presented to the user
  $tables_preserved = array();
  switch ($filter_option) {
    case 'none';
      $message = "Erased the entire database.";
      break;

    case 'min':
      $tables_preserved = $tables_filtered_l1;
      $message = "Erased the database, except for minimal preserved tables.";
      break;

    default:
      $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
      $message = "Erased the database, except for preserved tables.";
      break;
  }

  $filter = '';
  foreach($tables_preserved as $preserved_data) {
    $filter .= "|grep -v 'DROP TABLE IF EXISTS .$preserved_data.;'";
  }

  // Dump options to make it easy to erase the database
  $dump_options = "--add-drop-table --no-data";

  // We'll dump the database, perform some changes to it, then pipe it back into
  // MySQL so it will drop the given tables
  exec("$mysqldump $dump_options $db_connection_settings | grep 'DROP TABLE' $filter | $mysql $db_connection_settings");

  return "\n$message\n\n";
}


/**
 * Restore the database
 *
 * @param $branch
 *   File the database should be restored from.  Defaults to 'development'.
 *   Alternative options that are supported by default are 'production' and
 *   'last-merge'.  Other filename patterns may be used if you wish to restore
 *   the database from an alternate location.
 * @param $filter_option
 *   Choose what level of filtering should be performed during the restoration.
 *   Filter levels are configured in config.inc
 *   'full' - Default option.  Preserves the full option of data currently
 *       residing within MySQL. Most useful for preserving user, sessions and
 *       cache data.  Use this when restoring within a development environment.
 *   'min' - Preserves only a select minimum of data currently residing within
 *       MySQL.  Most useful for preserving sessions and cache data.  Use this
 *       when restoring within a production environment.
 *   'none' - NO filtering is performed whatsoever.  The entire database is
 *       erased from MySQL and restored with the data from the given file.
 */
function dbscripts_restore($branch = 'development', $filter_option = 'full') {
  require('config.inc');

  $db_connection_settings = dbscripts_db_connect();
  if (!$db_connection_settings) {
    return "\nImproper database connection settings.\n\n";
    exit;
  }

  // Set the location to restore from
  $dump_location = "$dump_path/$branch";

  // Check that the requested location exists
  if (!file_exists($dump_location)) {
    return "\nThe path does not exist: $dump_location\n\n";
    exit;
  }

  // Set behavior depending on filter
  $tables_preserved = array();
  switch($filter_option){
    case 'none':
      $message = "Restored the full database";
      break;

    case 'min':
      $tables_preserved = $tables_filtered_l1;
      $message = "Restored the database perserving minimal tables";
      break;

    default:
      $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
      $message = "Restored the database preserving the full option of tables";
      break;
  }

  // Get an array of tables to be restored -- the remainder will stay in the MySQL database
  $tables_restored = file("$dump_location/table_list.txt", FILE_IGNORE_NEW_LINES);
  foreach ($tables_restored as $key => $table) {
    // Since some tables are specified with a .*, generating other possible values
    $truncated = explode('_', $table);
    $truncated1 = isset($truncated[0]) ? $truncated[0].'_.*' : '';
    $truncated2 = isset($truncated[1]) ? $truncated[1].'_.*' : '';

    $check_tables = array($table, $truncated1, $truncated2);
    foreach ($check_tables as $check) {
      if (in_array($check, $tables_preserved)) {
        unset($tables_restored[$key]); // remove the table if it exists in $tables_preserved
      }
    }
  }

  // Erase the database so any tables that were removed stay removed
  dbscripts_erase($filter_option);

  // Restore each database file
  foreach ($tables_restored as $table) {
    if (file_exists("$dump_location/tables/$table.sql")) exec("$mysql $db_connection_settings < $dump_location/tables/$table.sql");
    if (file_exists("$dump_location/data/$table.sql")) exec("$mysql $db_connection_settings < $dump_location/data/$table.sql");
  }

  return "\n$message\n\n";
}


/**
 * Merge databases
 *
 * You really only need to set the following parameters for expert use.
 * Otherwise this function can be run with no options.
 *
 * @param $dev_branch
 *   Location of the database file that was used for 'development'.  Only
 *   configuration and content changes will be preserved.  All user data will
 *   be lost.
 * @param $lastmerge_branch
 *   Location of the database file that was used to represent the state the
 *   last time both production and development were merged.  This is important
 *   to be able to track the difference between an addition and a subtraction.
 * @param $prod_branch
 *   Location of the database file that is used as 'production'.  Only content
 *   and user data will be perserved.  All other data will be lost.
 */
function dbscripts_merge($dev_branch = 'development', $lastmerge_branch = 'last-merge', $prod_branch = 'production') {

  print "Not currently supported.";
  exit;

  require('config.inc');

  // If empty data gets sent through, reset it
  if (!$dev_branch) {
    $dev_branch = 'development';
  }
  if (!$lastmerge_branch) {
    $lastmerge_branch = 'last-merge';
  }
  if (!$prod_branch) {
    $prod_branch = 'production';
  }

  // Ensure all the files exist
  $missing_db = '';
  if (!file_exists("$dump_path/$dev_db.sql")) {
    $missing_db .= $dev_db.'.sql ';
  }
  if (!file_exists("$dump_path/$lastmerge_db.sql")) {
    $missing_db .= $lastmerge_db.'.sql ';
  }
  if (!file_exists("$dump_path/$prod_db.sql")) {
    $missing_db .= $prod_db.'.sql ';
  }

  // Cancel merge if all files do not exist
  if ($missing_db) {
    return "\nMissing database files for merge: $missing_db\n\n";
  }

  // Ensure tmp folder exists
  if (!file_exists($dump_path.'/tmp')) {
    exec("mkdir -p $dump_path/tmp");
  }

  // After a conflict, the temp files would still exist
  if(file_exists("$dump_path/tmp/data_merged.sql")){
    exec("rm $dump_path/tmp/*");
  }

  // Adding status indicators, because when it takes 15 minutes, it's nice to
  // know where you're at in the process.
  print "\nRestoring production database...";

  // To store production sequences, the full original production version of the
  // database will be loaded into MySQL.
  dbscripts_restore($prod_branch,'min');

  print " Done.";

  //Set up ability to strip data from tables
  $strip_merge = '';
  foreach($tables_merge as $table){
    $strip_content .= "|grep -v 'INSERT INTO .".$table.". VALUES' ";
  }
  $strip_override = '';
  foreach($tables_override as $table){
    $strip_users .= "|grep -v 'INSERT INTO .".$table.". VALUES' ";
  }

  // Set up ability to strip SQL comments
  $strip_comment = '';
  foreach($sql_comment_unset as $comment){
    $strip_comment .= "|grep -v '".$comment."' ";
  }

  // To ensure that the newly merged databases get imported into the database
  // correctly, tables that were modified to not be dropped in development,
  // need to be reversed
  $reverse_filter = '';
  $tables_preserved = array_merge($tables_filtered_l1,$tables_filtered_l2);
  foreach($tables_preserved as $table) {
    $reverse_filter .= "|sed 's/CREATE TABLE IF NOT EXISTS .".$table.". (/DROP TABLE IF EXISTS `".$table."`; CREATE TABLE `".$table."` (/g' ";
  }

  print "\n\nPreparing temporary files...";

  // Take development database and strip it of content and user data to
  // create a skeleton to work from (skeleton.sql)
  exec("cat $dump_path/$dev_db.sql $strip_merge $strip_override $strip_comment $reverse_filter > $dump_path/tmp/skeleton.sql");
  print "."; // ghetto status indicators

  // copy skeleton to where we'll be building the newly merged database
  exec("cp $dump_path/tmp/skeleton.sql $dump_path/tmp/merged_database.sql");
  print ".";

  //Add production user data to start building the newly merged database
  foreach($tables_override as $table){
    exec("grep 'INSERT INTO .".$table.". VALUES' $dump_path/$prod_db.sql >> $dump_path/tmp/data_user.sql");
    print ".";
  }
  exec("cat $dump_path/tmp/data_user.sql >> $dump_path/tmp/merged_database.sql");
  print ".";

  // Grab data from production, development and merged databases
  // Strip auto increment table sequences to avoid conflicts
  if(file_exists("$dump_path/tmp/data_dev.sql")){ exec("rm $dump_path/tmp/data_dev.sql"); }
  if(file_exists("$dump_path/tmp/data_prod.sql")){ exec("rm $dump_path/tmp/data_prod.sql"); }
  if(file_exists("$dump_path/tmp/data_lastmerge.sql")){ exec("rm $dump_path/tmp/data_lastmerge.sql"); }

  foreach($tables_merge as $table){
    exec("grep 'INSERT INTO .".$table.". VALUES' $dump_path/$dev_db.sql $strip_increment >> $dump_path/tmp/data_dev.sql");
    print ".";
    exec("grep 'INSERT INTO .".$table.". VALUES' $dump_path/$prod_db.sql $strip_increment >> $dump_path/tmp/data_prod.sql");
    print ".";
    exec("grep 'INSERT INTO .".$table.". VALUES' $dump_path/$lastmerge_db.sql $strip_increment >> $dump_path/tmp/data_lastmerge.sql");
    print ".";
  }

  // Create a new merged version of data (this step takes awhile)
  // NOTE: requires GNU diff3
  print " Done.  \n\nPerforming merge of data...";
  exec("diff3 -E --merge $dump_path/tmp/data_dev.sql $dump_path/tmp/data_lastmerge.sql $dump_path/tmp/data_prod.sql > $dump_path/tmp/data_merged.sql");

  // Check to see if the data merge had conflicts.  Otherwise, continue.
  $conflicts = exec("grep '^<<<<<<<' $dump_path/tmp/data_merged.sql");
  if($conflicts){

    $message = "\n\nWARNING: The database has conflicts!\n\n";

    $message .= "Please check $dump_path/tmp/data_merged.sql for what conflicted\n";
    $message .= "(hint: search for <<<<<<<), then:\n";
    $message .= "  * Resolve the conflicts manually\n";
    $message .= "  * Save $dump_path/tmp/data_merged.sql\n\n";

    $message .= "NOTE: If you want to default all conflicts to production values,\n
                  run this command instead of resolving manually:\n\n";

    $message .= "diff3 -e --merge $dump_path/tmp/data_dev.sql $dump_path/tmp/data_lastmerge.sql $dump_path/tmp/data_prod.sql > $dump_path/tmp/data_merged.sql\n\n";

    $message .= "After resolving conflicts, run the following commands\n
                  (just copy and paste):\n\n";

    $message .= "cat $dump_path/tmp/data_merged.sql >> $dump_path/tmp/merged_database.sql\n";
    $message .= "cp $dump_path/tmp/merged_database.sql $dump_path/$prod_db.sql\n";
    $message .= "$script_path/restore.php production min\n";
    $message .= "$script_path/dump.php production min\n";
    $message .= "cp $dump_path/tmp/merged_database.sql $dump_path/$dev_db.sql\n";
    $message .= "$script_path/restore.php $dev_branch\n";
    $message .= "$script_path/dump.php $dev_branch\n";
    $message .= "cp $dump_path/$dev_db.sql $dump_path/$lastmerge_db.sql\n";
    $message .= "$script_path/restore.php production min\n";

  } else {

    print " Successful! \n\nPreparing final files...";

    // Append the merged data to the merged version we're building
    exec("cat $dump_path/tmp/data_merged.sql >> $dump_path/tmp/merged_database.sql");
    print ".";

    // Apply the merged data to the databases
    exec("cp $dump_path/tmp/merged_database.sql $dump_path/$dev_db.sql");
    print ".";
    exec("cp $dump_path/tmp/merged_database.sql $dump_path/$prod_db.sql");
    print ".";


    // Restore and dump databases so they are formated correctly with correct
    // sequences for their version and prepared to be committed into svn.
    //
    // Production is restored first to align the database with the sequences currently
    // in MySQL (which is the production version), then restored again after
    // development to leave the MySQL status ready to be testing for the live version
    dbscripts_restore($prod_branch, 'min');
    print ".";
    dbscripts_dump($prod_branch, 'min');
    print ".";
    dbscripts_restore($dev_branch);
    print ".";
    dbscripts_dump($dev_branch);
    print ".";
    exec("cp $dump_path/$dev_db.sql $dump_path/$lastmerge_db.sql"); // Merged database is a copy of development
    print ".";
    dbscripts_restore($prod_branch, 'min');
    print ".";

    //Delete temp files
    exec("rm $dump_path/tmp/*");
    print " Done.";

    $message = "Merge completed successfully.  Congrats! Pat yourself on the back.\n";
  }

  return "\n\n$message\n";
}




